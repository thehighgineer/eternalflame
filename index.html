<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Visualizador de llamas – Múltiples modos</title>
  <!-- Tailwind para estilos básicos y UI cohesiva -->
  <script src="https://cdn.tailwindcss.com/3.3.5"></script>
  <style>
    /* Oculta temporalmente los contenedores según el modo */
    #flame-wrapper,
    #canvas2d {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    /* Panel de controles para modos 2D (esferas/abstracto) */
    #controls2d label {
      font-size: 12px;
    }
    #controls2d input[type="color"],
    #controls2d input[type="range"],
    #controls2d select,
    #controls2d input[type="checkbox"] {
      margin-left: 4px;
    }

    /* Unify the appearance of the original WebGL panel to match the 2D/3D panels */
    /* Override dark/light backgrounds to a consistent backdrop */
    #flame-wrapper .bg-slate-900\/80,
    #flame-wrapper .bg-white\/80 {
      background-color: rgba(0, 0, 0, 0.8) !important;
    }
    /* Harmonize border colors */
    #flame-wrapper .border-white\/10,
    #flame-wrapper .border-black\/10 {
      border-color: rgba(255, 255, 255, 0.1) !important;
    }
    /* Harmonize text colors */
    #flame-wrapper .text-slate-100,
    #flame-wrapper .text-neutral-900 {
      color: #f5f5f5 !important;
    }
    /* Slightly smaller header in original panel */
    #flame-wrapper h1 {
      font-size: 0.9rem !important;
    }
  </style>
</head>
<body class="bg-black text-white">
  <!-- Selector de modo global -->
  <div class="absolute top-2 left-2 z-20 bg-black/70 backdrop-blur px-3 py-2 rounded-lg border border-white/20">
    <label class="text-sm font-medium mr-2">Modo:</label>
    <select id="modeSelect" class="bg-black/60 text-white rounded-md border border-white/30 px-2 py-1">
      <option value="original">Original</option>
      <option value="spheres" selected>Esferas</option>
      <option value="abstract">Abstracto</option>
      <option value="custom">Personalizado</option>
      <option value="bars">Barras</option>
      <option value="lines">Líneas</option>
    </select>
  </div>

  <!-- Contenedor para el modo "original" (WebGL + React) -->
  <div id="flame-wrapper" style="display:none;"></div>

  <!-- Lienzo para modos 2D (esferas y abstracto) -->
  <canvas id="canvas2d"></canvas>

  <!-- Panel de control para modos 2D -->
  <!-- Unified control panel for 2D modes (esferas/abstracto/personalizado) -->
  <div id="controls2d" class="absolute right-3 top-3 z-20 w-[min(92vw,380px)] max-h-[calc(100%-24px)] rounded-2xl border shadow-xl backdrop-blur overflow-auto" style="display:block;">
    <!-- Header with title and hide button -->
    <div class="flex items-center justify-between px-3 py-2 border-b border-white/10">
      <div class="flex items-center gap-2">
        <h1 class="text-sm font-semibold tracking-wide">Visualizador 2D</h1>
        <span class="text-[11px] font-bold px-2 py-0.5 rounded-full" style="background: #fdcc0d; color: #111;">Live</span>
      </div>
      <button id="hidePanel2d" class="text-xs px-2 py-1 rounded-md border border-white/10 bg-white/10 hover:bg-white/20">Ocultar</button>
    </div>
    <div class="p-3 space-y-2">
      <!-- Color pickers: four colors -->
      <div class="grid grid-cols-[1fr_repeat(4,auto)] items-center gap-2">
        <label class="text-xs opacity-80">Colores</label>
        <input type="color" id="color1" value="#fdcc0d" />
        <input type="color" id="color2" value="#32527b" />
        <input type="color" id="color3" value="#fd6a00" />
        <input type="color" id="color4" value="#ffd26a" />
      </div>
      <!-- Sliders for behaviour -->
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Velocidad</label>
        <input type="range" id="speed" min="0.5" max="3" step="0.1" value="1" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Altura</label>
        <input type="range" id="height" min="0.5" max="3" step="0.1" value="1" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Anchura</label>
        <input type="range" id="width2d" min="0.5" max="3" step="0.1" value="1" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Turbulencia</label>
        <input type="range" id="turb2d" min="0" max="2" step="0.1" value="0" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Cantidad</label>
        <input type="range" id="count" min="10" max="1000" step="10" value="200" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Tamaño</label>
        <input type="range" id="size" min="0.5" max="3" step="0.1" value="1" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Resplandor</label>
        <input type="range" id="glow" min="0" max="5" step="0.1" value="1" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Viento constante</label>
        <input type="range" id="windConst" min="-2" max="2" step="0.1" value="0" class="w-44" />
      </div>
      <!-- Custom image upload (only visible in personalizado mode) -->
      <div class="grid grid-cols-[1fr_auto] items-center gap-3" id="customImageWrapper" style="display:none;">
        <label class="text-xs opacity-80">Imagen</label>
        <input type="file" id="customImage" accept="image/png" class="w-44" />
      </div>
      <!-- Toggles -->
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Micrófono</label>
        <input type="checkbox" id="micToggle" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Sensib. mic</label>
        <input type="range" id="micSens2d" min="0" max="2" step="0.1" value="1" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Viento táctil</label>
        <input type="checkbox" id="windToggle" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Granulado</label>
        <input type="checkbox" id="grainToggle" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Auto drift</label>
        <input type="checkbox" id="driftToggle" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Tema claro</label>
        <input type="checkbox" id="lightToggle" />
      </div>

      <!-- Rendimiento / pixel density slider -->
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Rendimiento</label>
        <input type="range" id="pixel2d" min="0.5" max="2" step="0.05" value="1" class="w-44" />
      </div>
      <!-- Buttons for randomizing and sharing settings -->
      <div class="grid grid-cols-2 gap-2">
        <button id="randomize2d" class="text-xs rounded-lg px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20">Aleatorizar</button>
        <button id="share2d" class="text-xs rounded-lg px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20">Compartir</button>
      </div>
    </div>
  </div>
  <div id="controls2dCollapsed" class="absolute right-3 top-3 z-20" style="display:none;">
    <button id="showPanel2d" class="text-xs px-3 py-2 rounded-md border border-white/10 bg-white/10 hover:bg-white/20">Mostrar panel</button>
  </div>

  <!-- Contenedor para modo 3D y su panel de control -->
  <div id="threeContainer" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%;"></div>
  <!-- Unified control panel for 3D mode -->
  <div id="controls3d" class="absolute right-3 top-3 z-20 w-[min(92vw,380px)] max-h-[calc(100%-24px)] rounded-2xl border shadow-xl backdrop-blur overflow-auto" style="display:none;">
    <!-- Header with title and hide button -->
    <div class="flex items-center justify-between px-3 py-2 border-b border-white/10">
      <div class="flex items-center gap-2">
        <h1 class="text-sm font-semibold tracking-wide">Visualizador 3D</h1>
        <span class="text-[11px] font-bold px-2 py-0.5 rounded-full" style="background: #fdcc0d; color: #111;">Live</span>
      </div>
      <button id="hidePanel3d" class="text-xs px-2 py-1 rounded-md border border-white/10 bg-white/10 hover:bg-white/20">Ocultar</button>
    </div>
    <div class="p-3 space-y-2">
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Modelo</label>
        <input type="file" id="modelFile" accept=".obj,.glb,.gltf" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Color</label>
        <input type="color" id="color3d" value="#ffffff" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Clones</label>
        <input type="range" id="count3d" min="1" max="50" step="1" value="5" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Escala</label>
        <input type="range" id="scale3d" min="0.1" max="3" step="0.1" value="0.5" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Vel. rotación</label>
        <input type="range" id="speed3d" min="-3" max="3" step="0.05" value="1" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Separación</label>
        <input type="range" id="spread3d" min="0" max="10" step="0.2" value="2" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Micrófono</label>
        <input type="checkbox" id="mic3d" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Sensib. mic</label>
        <input type="range" id="micSens3d" min="0" max="2" step="0.1" value="1" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Viento</label>
        <input type="range" id="wind3d" min="-2" max="2" step="0.1" value="0" class="w-44" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Auto drift</label>
        <input type="checkbox" id="drift3d" />
      </div>
      <div class="grid grid-cols-[1fr_auto] items-center gap-3">
        <label class="text-xs opacity-80">Tema claro</label>
        <input type="checkbox" id="light3d" />
      </div>
    </div>
  </div>
  <!-- Collapsed panel button for 3D mode -->
  <div id="controls3dCollapsed" class="absolute right-3 top-3 z-20" style="display:none;">
    <button id="showPanel3d" class="text-xs px-3 py-2 rounded-md border border-white/10 bg-white/10 hover:bg-white/20">Mostrar panel</button>
  </div>

  <!-- Branding that hides with the control panel and watermark always visible -->
  <div id="branding" class="absolute right-3 bottom-24 z-20 text-xs opacity-70 pointer-events-none">Spatialgineers Visualizers</div>
  <div id="watermark" class="absolute left-3 bottom-3 z-20 text-xs opacity-40 pointer-events-none">Spatialgineers Visualizers</div>

  <!-- La versión 3D se implementa a mano sin dependencias externas para evitar problemas de carga. -->

  <!-- React y Babel para el modo "original" -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Se eliminan las dependencias de Three.js y sus cargadores porque el modo 3D ya no está disponible -->

  <script type="text/babel">
    /*
     * Código de React para el modo "original". Utiliza el componente EternalFlameCanvas
     * del visualizador WebGL avanzado, conservando todos los controles y presets.
     * Este código se ejecuta cuando el modo seleccionado es "original".
     */

    // Funciones utilitarias
    function hexToRgb(hex) {
      let h = hex.replace('#', '');
      if (h.length === 3) h = h.split('').map((c) => c + c).join('');
      const num = parseInt(h, 16);
      return [((num >> 16) & 255) / 255, ((num >> 8) & 255) / 255, (num & 255) / 255];
    }
    function rgbToHex(rgb) {
      return (
        '#' +
        rgb
          .map((v) => Math.round(v * 255).toString(16).padStart(2, '0'))
          .join('')
      );
    }
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
    const lerp = (a, b, t) => a + (b - a) * t;

    // Presets de colores y parámetros (incluyendo preset Spatialgineers)
    const PRESETS = {
      classic: {
        cBase: '#3a0d00',
        cMid: '#fd6a00',
        cHot: '#ffd26a',
        cBg: '#000000',
        speed: 1.0,
        turb: 1.0,
        height: 1.2,
        width: 1.4,
        contrast: 1.4,
        glow: 0.6,
        wind: 0.3,
        detail: 5,
      },
      blue: {
        cBase: '#002033',
        cMid: '#1e7fdd',
        cHot: '#a8d7ff',
        cBg: '#00040a',
        speed: 0.9,
        turb: 1.1,
        height: 1.4,
        width: 1.2,
        contrast: 1.6,
        glow: 0.9,
        wind: 0.2,
        detail: 6,
      },
      neon: {
        cBase: '#3a0066',
        cMid: '#ff00e5',
        cHot: '#fdcc0d',
        cBg: '#020008',
        speed: 1.2,
        turb: 1.3,
        height: 1.1,
        width: 1.6,
        contrast: 1.2,
        glow: 1.2,
        wind: 0.5,
        detail: 5,
      },
      brand: {
        cBase: '#0a1622',
        cMid: '#32527b',
        cHot: '#fdcc0d',
        cBg: '#000000',
        speed: 1.0,
        turb: 1.2,
        height: 1.3,
        width: 1.5,
        contrast: 1.3,
        glow: 1.0,
        wind: 0.25,
        detail: 6,
      },
    };

    // Componente principal: EternalFlameCanvas
    function EternalFlameCanvas() {
      const containerRef = React.useRef(null);
      const canvasRef = React.useRef(null);
      const glRef = React.useRef(null);
      const programRef = React.useRef(null);
      const uniformsRef = React.useRef({});
      const rafRef = React.useRef(0);
      const t0Ref = React.useRef(performance.now());
      const lastTRef = React.useRef(performance.now());
      const dprRef = React.useRef(1);
      const micRef = React.useRef({ ctx: null, analyser: null, data: null, on: false, env: 0, sensitivity: 1 });
      const stateRef = React.useRef({
        base: hexToRgb(PRESETS.classic.cBase),
        mid: hexToRgb(PRESETS.classic.cMid),
        hot: hexToRgb(PRESETS.classic.cHot),
        bg: hexToRgb(PRESETS.classic.cBg),
        speed: PRESETS.classic.speed,
        turb: PRESETS.classic.turb,
        height: PRESETS.classic.height,
        width: PRESETS.classic.width,
        contrast: PRESETS.classic.contrast,
        glow: PRESETS.classic.glow,
        wind: PRESETS.classic.wind,
        detail: PRESETS.classic.detail,
        grain: 1.0,
        pixel: 1.0,
        drift: true,
        seed: Math.random() * 1000,
        audio: 0.0,
        touchWind: false,
        themeLight: false,
      });

      const [ui, setUi] = React.useState({
        ...PRESETS.classic,
        cBase: PRESETS.classic.cBase,
        cMid: PRESETS.classic.cMid,
        cHot: PRESETS.classic.cHot,
        cBg: PRESETS.classic.cBg,
        grain: true,
        drift: true,
        pixel: 1.0,
        micReactive: false,
        micSensitivity: 1.0,
        touchWind: false,
        themeLight: false,
        fps: '—',
        panelOpen: true,
      });

      const [toast, setToast] = React.useState('');
      React.useEffect(() => {
        if (!toast) return;
        const id = setTimeout(() => setToast(''), 1600);
        return () => clearTimeout(id);
      }, [toast]);

      // Construye y compila shaders
      function makeProgram(gl) {
        const vsSrc = `
          attribute vec2 a_position;
          varying vec2 v_uv;
          void main(){
            v_uv = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
          }
        `;
        const fsSrc = `
          precision mediump float;
          varying vec2 v_uv;
          uniform vec2 u_res;
          uniform float u_time;
          uniform float u_seed;
          uniform vec3 u_base;
          uniform vec3 u_mid;
          uniform vec3 u_hot;
          uniform vec3 u_bg;
          uniform float u_speed;
          uniform float u_turb;
          uniform float u_height;
          uniform float u_width;
          uniform float u_contrast;
          uniform float u_glow;
          uniform float u_wind;
          uniform int   u_detail;
          uniform float u_grain;
          uniform float u_audio;

          float hash21(vec2 p){
            p = fract(p*vec2(123.34,345.45));
            p += dot(p,p+34.345);
            return fract(p.x*p.y);
          }
          float noise(vec2 p){
            vec2 i = floor(p);
            vec2 f = fract(p);
            float a = hash21(i);
            float b = hash21(i+vec2(1.,0.));
            float c = hash21(i+vec2(0.,1.));
            float d = hash21(i+vec2(1.,1.));
            vec2 u = f*f*(3.-2.*f);
            return mix(a,b,u.x) + (c-a)*u.y*(1.-u.x) + (d-b)*u.x*u.y;
          }
          mat2 rot(float a){ float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }
          float fbm(vec2 p, int oct){
            float v=0.; float a=0.5;
            for(int i=0;i<8;i++){
              if(i>=oct) break;
              v += a*noise(p);
              p = rot(0.5)*p*2.0 + 10.0;
              a *= 0.5;
            }
            return v;
          }
          vec3 palette(float t, vec3 c1, vec3 c2, vec3 c3){
            float m1 = smoothstep(0.,0.6,t);
            float m2 = smoothstep(0.3,1.,t);
            vec3 c = mix(c1,c2,m1);
            c = mix(c,c3,m2);
            return c;
          }
          void main(){
            vec2 uv = v_uv;
            float aspect = u_res.x/u_res.y;
            vec2 p = vec2((uv.x-0.5)*aspect, uv.y);

            // Increase audio modulation impact for more visible mic reactivity
            float t = u_time * (0.3 + u_speed*0.7) * (1.0 + u_audio*1.0);
            vec2 seed = vec2(u_seed, u_seed*1.618);

            vec2 q = vec2(
              fbm(p*2.0 + vec2(0.0, t*1.2) + seed, u_detail),
              fbm(p*2.0 + vec2(5.2, t*1.2) - seed, u_detail)
            );
            vec2 r = vec2(
              fbm(p*3.0 + (u_turb + u_audio*1.2)*q + vec2(1.7, t*1.7) + seed*2.0, u_detail),
              fbm(p*3.0 + (u_turb + u_audio*1.2)*q + vec2(9.2, t*1.7) - seed*2.0, u_detail)
            );

            float flameWidth = u_width;
            float flameShape = 1.0 - (abs(p.x*flameWidth) + (1.0-uv.y)*(u_height - u_audio*1.0));
            flameShape = smoothstep(-1.2, 0.5, flameShape);

            float n = fbm(p*2.0 + r*1.2 + vec2((u_wind + u_audio*0.6)*t*0.3, -t*2.0), u_detail);
            n = pow(clamp(n,0.0,1.0), 1.2);

            float intensity = clamp(n*flameShape, 0.0, 1.0);
            intensity = pow(intensity, u_contrast) * (1.0 + u_audio*1.0);

            vec3 col = mix(u_bg, palette(intensity, u_base, u_mid, u_hot), intensity);
            float glow = smoothstep(0.0, 0.8, intensity) * (u_glow + u_audio*2.0);
            col += glow * vec3(1.0, 0.7, 0.3);

            if(u_grain > 0.5){
              float g = hash21(uv*u_res.xy + fract(t))*0.04;
              col += g;
            }
            gl_FragColor = vec4(col,1.0);
          }
        `;

        function compile(src, type) {
          const sh = gl.createShader(type);
          gl.shaderSource(sh, src);
          gl.compileShader(sh);
          if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
            throw new Error('Shader error: ' + gl.getShaderInfoLog(sh));
          }
          return sh;
        }

        const vs = compile(vsSrc, gl.VERTEX_SHADER);
        const fs = compile(fsSrc, gl.FRAGMENT_SHADER);
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          throw new Error('Link error: ' + gl.getProgramInfoLog(prog));
        }
        gl.useProgram(prog);

        const attribPos = gl.getAttribLocation(prog, 'a_position');
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([-1, -1, 3, -1, -1, 3]),
          gl.STATIC_DRAW
        );
        gl.enableVertexAttribArray(attribPos);
        gl.vertexAttribPointer(attribPos, 2, gl.FLOAT, false, 0, 0);

        const U = (name) => gl.getUniformLocation(prog, name);
        uniformsRef.current = {
          u_res: U('u_res'),
          u_time: U('u_time'),
          u_seed: U('u_seed'),
          u_base: U('u_base'),
          u_mid: U('u_mid'),
          u_hot: U('u_hot'),
          u_bg: U('u_bg'),
          u_speed: U('u_speed'),
          u_turb: U('u_turb'),
          u_height: U('u_height'),
          u_width: U('u_width'),
          u_contrast: U('u_contrast'),
          u_glow: U('u_glow'),
          u_wind: U('u_wind'),
          u_detail: U('u_detail'),
          u_grain: U('u_grain'),
          u_audio: U('u_audio'),
        };

        return prog;
      }

      // Resize observer
      React.useEffect(() => {
        const container = containerRef.current;
        const canvas = canvasRef.current;
        if (!container || !canvas) return;
        const gl = (glRef.current = canvas.getContext('webgl', {
          antialias: false,
          alpha: false,
          depth: false,
          stencil: false,
          preserveDrawingBuffer: false,
        }));
        if (!gl) return;
        programRef.current = makeProgram(gl);
        const resizeToContainer = () => {
          const rect = container.getBoundingClientRect();
          const targetDpr = clamp((window.devicePixelRatio || 1) * stateRef.current.pixel, 0.5, 2.0);
          dprRef.current = targetDpr;
          const w = Math.max(1, Math.floor(rect.width * targetDpr));
          const h = Math.max(1, Math.floor(rect.height * targetDpr));
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
            gl.viewport(0, 0, w, h);
          }
        };
        const ro = new ResizeObserver(resizeToContainer);
        ro.observe(container);
        resizeToContainer();

        let frames = 0;
        let fpsAcc = 0;
        const draw = (now) => {
          const U = uniformsRef.current;
          const gl = glRef.current;
          if (!gl) return;
          // Drift y glow
          if (stateRef.current.drift) {
            const tt = (now - t0Ref.current) / 1000;
            targetWindRef.current = lerp(targetWindRef.current, Math.sin(tt * 0.15 + stateRef.current.seed) * 0.6, 0.02);
            stateRef.current.glow = lerp(stateRef.current.glow, 0.8 + Math.sin(tt * 0.25) * 0.4, 0.02);
          }
          // Ease wind
          stateRef.current.wind = lerp(stateRef.current.wind, targetWindRef.current, 0.08);
          // Mic envelope
          stateRef.current.audio = micEnvelope();
          gl.uniform2f(U.u_res, canvas.width, canvas.height);
          gl.uniform1f(U.u_time, (now - t0Ref.current) / 1000);
          gl.uniform1f(U.u_seed, stateRef.current.seed);
          gl.uniform3f(U.u_base, ...stateRef.current.base);
          gl.uniform3f(U.u_mid, ...stateRef.current.mid);
          gl.uniform3f(U.u_hot, ...stateRef.current.hot);
          gl.uniform3f(U.u_bg, ...stateRef.current.bg);
          gl.uniform1f(U.u_speed, stateRef.current.speed);
          gl.uniform1f(U.u_turb, stateRef.current.turb);
          gl.uniform1f(U.u_height, stateRef.current.height);
          gl.uniform1f(U.u_width, stateRef.current.width);
          gl.uniform1f(U.u_contrast, stateRef.current.contrast);
          gl.uniform1f(U.u_glow, stateRef.current.glow);
          gl.uniform1f(U.u_wind, stateRef.current.wind);
          gl.uniform1i(U.u_detail, stateRef.current.detail);
          gl.uniform1f(U.u_grain, stateRef.current.grain);
          gl.uniform1f(U.u_audio, stateRef.current.audio);
          gl.drawArrays(gl.TRIANGLES, 0, 3);
          const dt = now - lastTRef.current;
          lastTRef.current = now;
          frames++;
          fpsAcc += dt;
          if (fpsAcc >= 500) {
            const fps = Math.round((frames * 1000) / fpsAcc);
            setUi((u) => ({ ...u, fps: String(fps) }));
            frames = 0;
            fpsAcc = 0;
          }
          rafRef.current = requestAnimationFrame(draw);
        };
        rafRef.current = requestAnimationFrame(draw);
        return () => {
          cancelAnimationFrame(rafRef.current);
          ro.disconnect();
        };
      }, []);

      // Pointer-driven wind para React
      const lastPointerX = React.useRef(null);
      const targetWindRef = React.useRef(0.3);
      React.useEffect(() => {
        function onMove(e) {
          if (!stateRef.current.touchWind) return;
          const x = e.touches ? e.touches[0].clientX : e.clientX;
          if (lastPointerX.current == null) {
            lastPointerX.current = x;
            return;
          }
          const dx = x - lastPointerX.current;
          lastPointerX.current = x;
          const norm = clamp(dx / window.innerWidth, -1, 1);
          targetWindRef.current = clamp(stateRef.current.wind + norm * 1.2, -2, 2);
        }
        function onUp() {
          lastPointerX.current = null;
        }
        window.addEventListener('pointermove', onMove, { passive: true });
        window.addEventListener('touchmove', onMove, { passive: true });
        window.addEventListener('pointerup', onUp, { passive: true });
        window.addEventListener('touchend', onUp, { passive: true });
        return () => {
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('touchmove', onMove);
          window.removeEventListener('pointerup', onUp);
          window.removeEventListener('touchend', onUp);
        };
      }, []);

      // Mic reactivity
      async function initMic() {
        try {
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          const src = ctx.createMediaStreamSource(stream);
          const analyser = ctx.createAnalyser();
          analyser.fftSize = 1024;
          src.connect(analyser);
          micRef.current = {
            ctx,
            analyser,
            data: new Uint8Array(analyser.frequencyBinCount),
            on: true,
            env: 0,
            sensitivity: ui.micSensitivity,
          };
          setToast('Mic on');
          setUi((u) => ({ ...u, micReactive: true }));
        } catch (e) {
          setToast('Mic blocked/unavailable');
          setUi((u) => ({ ...u, micReactive: false }));
        }
      }
      function micEnvelope() {
        const m = micRef.current;
        if (!m || !m.analyser || !ui.micReactive) return 0;
        m.analyser.getByteFrequencyData(m.data);
        const bins = Math.min(40, m.data.length);
        let sum = 0;
        for (let i = 1; i < bins; i++) sum += m.data[i];
        let avg = sum / bins / 255;
        // Amplificar la señal de audio para mayor reactividad (factor aumentado)
        avg *= 6.0;
        m.env = lerp(m.env, avg, 0.25);
        // Ajustar el límite máximo para permitir más efecto visual
        return clamp(m.env * (m.sensitivity || 1), 0, 4.0);
      }

      // Share link
      const shareLink = async () => {
        const sr = stateRef.current;
        const params = new URLSearchParams({
          v: 'canvas',
          c1: rgbToHex(sr.base).slice(1),
          c2: rgbToHex(sr.mid).slice(1),
          c3: rgbToHex(sr.hot).slice(1),
          cb: rgbToHex(sr.bg).slice(1),
          sp: sr.speed.toFixed(2),
          tb: sr.turb.toFixed(2),
          he: sr.height.toFixed(2),
          wi: sr.width.toFixed(2),
          ct: sr.contrast.toFixed(2),
          gl: sr.glow.toFixed(2),
          wd: sr.wind.toFixed(2),
          de: String(sr.detail),
          gr: sr.grain > 0.5 ? '1' : '0',
          th: ui.themeLight ? '1' : '0',
        });
        const url = window.location.origin + window.location.pathname + '#' + params.toString();
        try {
          await navigator.clipboard.writeText(url);
          setToast('Link copied');
        } catch {
          setToast('Copy failed');
        }
      };

      // UI -> state mapping functions
      const updateColor = (key, value) => {
        setUi((u) => ({ ...u, [key]: value }));
        const map = { cBase: 'base', cMid: 'mid', cHot: 'hot', cBg: 'bg' };
        stateRef.current[map[key]] = hexToRgb(value);
      };
      const updateNum = (key, value) => {
        setUi((u) => ({ ...u, [key]: value }));
        stateRef.current[key] = typeof value === 'boolean' ? (value ? 1.0 : 0.0) : value;
        if (key === 'grain') stateRef.current.grain = value ? 1.0 : 0.0;
        if (key === 'pixel') {
          stateRef.current.pixel = value;
          const c = canvasRef.current;
          if (c) {
            const gl = glRef.current;
            const rect = containerRef.current.getBoundingClientRect();
            const targetDpr = clamp((window.devicePixelRatio || 1) * value, 0.5, 2.0);
            dprRef.current = targetDpr;
            const w = Math.max(1, Math.floor(rect.width * targetDpr));
            const h = Math.max(1, Math.floor(rect.height * targetDpr));
            if (c.width !== w || c.height !== h) {
              c.width = w;
              c.height = h;
              gl.viewport(0, 0, w, h);
            }
          }
        }
      };

      // Presets
      const applyPreset = (p) => {
        setUi((u) => ({ ...u, ...p }));
        Object.assign(stateRef.current, {
          base: hexToRgb(p.cBase),
          mid: hexToRgb(p.cMid),
          hot: hexToRgb(p.cHot),
          bg: hexToRgb(p.cBg),
          speed: p.speed,
          turb: p.turb,
          height: p.height,
          width: p.width,
          contrast: p.contrast,
          glow: p.glow,
          wind: p.wind,
          detail: p.detail,
        });
        targetWindRef.current = p.wind;
        stateRef.current.seed = Math.random() * 1000;
      };

      // Render UI
      return (
        <div ref={containerRef} className={(ui.themeLight ? 'bg-white text-black' : 'bg-black text-white') + ' w-full h-full relative'}>
          <canvas ref={canvasRef} className="absolute inset-0 w-full h-full block" />
          {/* Panel de control de React */}
          {ui.panelOpen && (
            <div className={
              'absolute right-3 top-3 z-10 w-[min(92vw,380px)] max-h-[calc(100%-24px)] rounded-2xl border shadow-xl backdrop-blur overflow-auto ' +
              (ui.themeLight ? 'bg-white/80 border-black/10 text-neutral-900' : 'bg-slate-900/80 border-white/10 text-slate-100')
            }>
              <div className="flex items-center justify-between px-3 py-2 border-b border-white/10">
                <h1 className="text-sm font-semibold tracking-wide">Eternal Flame</h1>
                <span className="text-[11px] font-bold px-2 py-0.5 rounded-full" style={{ background: '#fdcc0d', color: '#111' }}>
                  Live
                </span>
              </div>
              <div className="p-3 space-y-2">
                {/* Presets */}
                <div className="grid grid-cols-4 gap-2">
                  <button className="text-xs rounded-full px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20" onClick={() => applyPreset(PRESETS.classic)}>Classic</button>
                  <button className="text-xs rounded-full px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20" onClick={() => applyPreset(PRESETS.blue)}>Blue</button>
                  <button className="text-xs rounded-full px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20" onClick={() => applyPreset(PRESETS.neon)}>Neon</button>
                  <button className="text-xs rounded-full px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20" onClick={() => applyPreset(PRESETS.brand)}>Spatialgineers</button>
                </div>
                {/* Colores */}
                <div className="grid grid-cols-[1fr_repeat(4,auto)] items-center gap-2">
                  <label className="text-xs opacity-80">Colores</label>
                  <input type="color" value={ui.cBase} onChange={(e) => updateColor('cBase', e.target.value)} />
                  <input type="color" value={ui.cMid} onChange={(e) => updateColor('cMid', e.target.value)} />
                  <input type="color" value={ui.cHot} onChange={(e) => updateColor('cHot', e.target.value)} />
                  <input type="color" value={ui.cBg} onChange={(e) => updateColor('cBg', e.target.value)} />
                </div>
                {/* Deslizadores */}
                {[
                  ['Velocidad', 'speed', 0, 2, 0.01],
                  ['Turbulencia', 'turb', 0, 2, 0.01],
                  ['Altura', 'height', 0.2, 2.0, 0.01],
                  ['Anchura', 'width', 0.6, 3.0, 0.01],
                  ['Contraste', 'contrast', 0.4, 3.0, 0.01],
                  ['Resplandor', 'glow', 0, 3, 0.01],
                  ['Viento', 'wind', -2, 2, 0.01],
                  ['Detalle', 'detail', 1, 7, 1],
                  ['Performance', 'pixel', 0.5, 2.0, 0.05],
                ].map(([label, key, min, max, step]) => (
                  <div key={key} className="grid grid-cols-[1fr_auto] items-center gap-3">
                    <label className="text-xs opacity-80">{label}</label>
                    <input
                      type="range"
                      min={min}
                      max={max}
                      step={step}
                      value={ui[key]}
                      onChange={(e) => updateNum(key, key === 'detail' ? parseInt(e.target.value, 10) : parseFloat(e.target.value))}
                      className="w-44"
                    />
                  </div>
                ))}
                {/* Interruptores */}
                <div className="grid grid-cols-[1fr_auto] items-center gap-3">
                  <label className="text-xs opacity-80">Auto drift</label>
                  <input type="checkbox" checked={ui.drift} onChange={(e) => { setUi((u) => ({ ...u, drift: e.target.checked })); stateRef.current.drift = e.target.checked; }} />
                </div>
                <div className="grid grid-cols-[1fr_auto] items-center gap-3">
                  <label className="text-xs opacity-80">Film grain</label>
                  <input type="checkbox" checked={ui.grain} onChange={(e) => updateNum('grain', e.target.checked)} />
                </div>
                <div className="grid grid-cols-[1fr_auto] items-center gap-3">
                  <label className="text-xs opacity-80">Mic reactivo</label>
                  <input
                    type="checkbox"
                    checked={ui.micReactive}
                    onChange={async (e) => {
                      if (e.target.checked) await initMic();
                      else {
                        micRef.current.on = false;
                        setUi((u) => ({ ...u, micReactive: false }));
                      }
                    }}
                  />
                </div>
                <div className="grid grid-cols-[1fr_auto] items-center gap-3">
                  <label className="text-xs opacity-80">Sensibilidad Mic</label>
                  <input
                    type="range"
                    min={0}
                    max={2}
                    step={0.01}
                    value={ui.micSensitivity}
                    onChange={(e) => {
                      const v = parseFloat(e.target.value);
                      setUi((u) => ({ ...u, micSensitivity: v }));
                      micRef.current.sensitivity = v;
                    }}
                    className="w-44"
                  />
                </div>
                <div className="grid grid-cols-[1fr_auto] items-center gap-3">
                  <label className="text-xs opacity-80">Viento táctil</label>
                  <input type="checkbox" checked={ui.touchWind} onChange={(e) => { setUi((u) => ({ ...u, touchWind: e.target.checked })); stateRef.current.touchWind = e.target.checked; setToast(e.target.checked ? 'Touch wind on' : 'Touch wind off'); }} />
                </div>
                <div className="grid grid-cols-[1fr_auto] items-center gap-3">
                  <label className="text-xs opacity-80">Tema claro</label>
                  <input type="checkbox" checked={ui.themeLight} onChange={(e) => setUi((u) => ({ ...u, themeLight: e.target.checked }))} />
                </div>
                <div className="grid grid-cols-2 gap-2">
                  <button className="text-xs rounded-lg px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20" onClick={() => { stateRef.current.seed = Math.random() * 1000; setToast('Randomized'); }}>Randomizar</button>
                  <button className="text-xs rounded-lg px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20" onClick={shareLink}>Compartir</button>
                </div>
                <div className="flex items-center justify-between text-[11px] opacity-80 pt-1">
                  <span>FPS: {ui.fps}</span>
                  <button className="text-xs px-2 py-1 rounded-md border border-white/10" onClick={() => setUi((u) => ({ ...u, panelOpen: !u.panelOpen }))}>{ui.panelOpen ? 'Ocultar panel' : 'Mostrar panel'}</button>
                </div>
              </div>
            </div>
          )}
          {/* Toast */}
          {toast && (
            <div className="absolute left-1/2 -translate-x-1/2 bottom-4 px-3 py-2 rounded-xl border border-white/10 bg-black/70 text-white text-xs shadow-lg">
              {toast}
            </div>
          )}
        </div>
      );
    }

    // Exponer el componente a nivel global para que otros scripts puedan montarlo
    window.EternalFlameCanvas = EternalFlameCanvas;
  </script>

  <script>
    /*
     * Código JavaScript plano para los modos 2D: "spheres", "abstract" y "custom".
     * Permite partículas en 2D que se elevan con gradientes radiales (esferas),
     * formas abstractas en órbita y partículas personalizadas basadas en imágenes PNG.
     * Incluye controles para colores, velocidad, altura, cantidad, tamaño y resplandor.
     * Soporta micrófono (amplifica las partículas) y viento táctil.
     */
    (function() {
      const canvas = document.getElementById('canvas2d');
      const ctx = canvas.getContext('2d');
      let width = 0, height = 0;
      function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
      }
      window.addEventListener('resize', resize);
      resize();

      // Configuración inicial del modo 2D con controles avanzados
      const settings = {
        mode: 'spheres',
        color1: '#fdcc0d',
        color2: '#32527b',
        // Nuevos colores para gradientes de 4 puntos
        color3: '#fd6a00',
        color4: '#ffd26a',
        speed: 1,
        height: 1,
        width: 1,
        turb: 0,
        count: 200,
        size: 1,
        glow: 1,
        windConst: 0,
        image: null,
        micSensitivity: 1,
        pointerWind: false,
        grain: false,
        drift: false,
        themeLight: false
      };

      let particles = [];
      let abstracts = [];
      let customParticles = [];
      // Arreglo de líneas para el nuevo modo "Líneas"
      let lines = [];
      let wind = 0;
      let targetWind = 0;

      // Offsets for abstract mode translations (for directional movement). These
      // values accumulate each frame to shift the entire abstract pattern
      // horizontally or vertically based on the selected direction. They are
      // wrapped within the canvas dimensions to avoid drifting off-screen.
      let abstractOffsetX = 0;
      let abstractOffsetY = 0;

      // Herramienta de interpolación de colores para modo barras
      // Convierte un color hexadecimal a sus componentes RGB
      function hexToRgbComponents(hex) {
        const h = hex.replace('#', '');
        const r = parseInt(h.substring(0, 2), 16);
        const g = parseInt(h.substring(2, 4), 16);
        const b = parseInt(h.substring(4, 6), 16);
        return [r, g, b];
      }
      // Interpola entre dos colores hexadecimales según t (0 a 1) y devuelve un nuevo color en formato hex
      function lerpColorHex(a, b, t) {
        const ar = parseInt(a.substring(1, 3), 16);
        const ag = parseInt(a.substring(3, 5), 16);
        const ab = parseInt(a.substring(5, 7), 16);
        const br = parseInt(b.substring(1, 3), 16);
        const bg = parseInt(b.substring(3, 5), 16);
        const bb = parseInt(b.substring(5, 7), 16);
        const rr = Math.round(ar + (br - ar) * t);
        const gg = Math.round(ag + (bg - ag) * t);
        const bb2 = Math.round(ab + (bb - ab) * t);
        return '#' + rr.toString(16).padStart(2, '0') + gg.toString(16).padStart(2, '0') + bb2.toString(16).padStart(2, '0');
      }

      // 3D engine: parámetros y datos
      const settings3d = {
        color: '#ffffff', // color base de los clones
        count: 5,        // número de clones a dibujar
        scale: 0.5,        // escala base de cada clon (valor por defecto reducido)
        speed: 1,        // velocidad de rotación (y)
        spread: 2,       // radio de separación de clones
        micSensitivity: 1, // sensibilidad del micrófono
        wind: 0,         // rotación en X (viento)
        drift: false,    // drift automático del viento
        themeLight: false // tema claro/oscuro para 3D
      };
      let clones3d = [];
      // Placeholder for loaded OBJ geometry. When null, spheres will be drawn.
      let modelGeometry3d = null;
      let micCtx3d = null;
      let micAnalyser3d = null;
      let micData3d = null;
      let micOn3d = false;
      // Invertir un color hexadecimal
      function invertColor3D(hex) {
        const h = hex.replace('#', '');
        const num = parseInt(h.length === 3 ? h.split('').map((c) => c + c).join('') : h, 16);
        const inv = 0xffffff ^ num;
        return '#' + inv.toString(16).padStart(6, '0');
      }

      // Parse a simple OBJ file (only vertices and faces). Returns normalized geometry.
      function parseOBJ(text) {
        const vertices = [];
        const faces = [];
        const lines = text.split(/[\r\n]+/);
        lines.forEach((line) => {
          const parts = line.trim().split(/\s+/);
          if (parts.length === 0) return;
          if (parts[0] === 'v' && parts.length >= 4) {
            const x = parseFloat(parts[1]);
            const y = parseFloat(parts[2]);
            const z = parseFloat(parts[3]);
            if (!isNaN(x) && !isNaN(y) && !isNaN(z)) vertices.push([x, y, z]);
          } else if (parts[0] === 'f' && parts.length >= 4) {
            const idx = parts.slice(1).map((p) => {
              const n = p.split('/')[0];
              return parseInt(n, 10) - 1;
            }).filter((i) => !isNaN(i));
            if (idx.length >= 3) {
              for (let i = 1; i < idx.length - 1; i++) {
                faces.push([idx[0], idx[i], idx[i + 1]]);
              }
            }
          }
        });
        if (vertices.length === 0 || faces.length === 0) {
          return null;
        }
        // Center and scale to fit within unit cube
        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
        vertices.forEach((v) => {
          if (v[0] < minX) minX = v[0];
          if (v[0] > maxX) maxX = v[0];
          if (v[1] < minY) minY = v[1];
          if (v[1] > maxY) maxY = v[1];
          if (v[2] < minZ) minZ = v[2];
          if (v[2] > maxZ) maxZ = v[2];
        });
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;
        const cz = (minZ + maxZ) / 2;
        const dx = maxX - minX;
        const dy = maxY - minY;
        const dz = maxZ - minZ;
        const scale = 1 / Math.max(dx, dy, dz || 1);
        const normVertices = vertices.map((v) => [
          (v[0] - cx) * scale,
          (v[1] - cy) * scale,
          (v[2] - cz) * scale,
        ]);
        return { vertices: normVertices, faces };
      }
      // Inicializar micrófono para 3D
      function initMic3d() {
        if (micOn3d) return;
        navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
          micCtx3d = new (window.AudioContext || window.webkitAudioContext)();
          micAnalyser3d = micCtx3d.createAnalyser();
          micAnalyser3d.fftSize = 256;
          const source = micCtx3d.createMediaStreamSource(stream);
          source.connect(micAnalyser3d);
          micData3d = new Uint8Array(micAnalyser3d.frequencyBinCount);
          micOn3d = true;
        }).catch((err) => {
          console.error('Error al acceder al micrófono 3D:', err);
        });
      }
      function getMicLevel3d() {
        if (!micOn3d || !micAnalyser3d) return 0;
        micAnalyser3d.getByteFrequencyData(micData3d);
        let sum = 0;
        for (let i = 0; i < micData3d.length; i++) sum += micData3d[i];
        return sum / micData3d.length / 255;
      }
      // Crear clones iniciales para 3D
      function init3d() {
        clones3d = [];
        const total = Math.max(1, settings3d.count);
        for (let i = 0; i < total; i++) {
          clones3d.push({ index: i });
        }
        // Ajustar color de fondo del lienzo según el tema del modo 3D
        document.getElementById('canvas2d').style.backgroundColor = settings3d.themeLight ? '#ffffff' : '#000000';
        // Crear o recrear clones utilizando Three.js (si está disponible)
        if (typeof THREE !== 'undefined') {
          createClones3d();
        }
      }
      // Dibujar los clones 3D con perspectiva simple
      function draw3d(micMult, beat) {
        // Fondo según tema
        ctx.fillStyle = settings3d.themeLight ? '#ffffff' : '#000000';
        ctx.fillRect(0, 0, width, height);
        const radius = settings3d.spread;
        const time = Date.now() * 0.001;
        const colorNorm = settings3d.color;
        const colorBeat = invertColor3D(colorNorm);
        // Si hay geometría de modelo cargada, dibujar polígonos; de lo contrario, esferas
        if (modelGeometry3d && modelGeometry3d.vertices && modelGeometry3d.faces) {
          const d = 6;
          const allFaces = [];
          const total = Math.max(1, settings3d.count);
          // Precalcular base color RGB
          const rgbNorm = colorNorm.replace('#', '');
          const baseR = parseInt(rgbNorm.substring(0, 2), 16);
          const baseG = parseInt(rgbNorm.substring(2, 4), 16);
          const baseB = parseInt(rgbNorm.substring(4, 6), 16);
          const rgbBeat = colorBeat.replace('#', '');
          const beatR = parseInt(rgbBeat.substring(0, 2), 16);
          const beatG = parseInt(rgbBeat.substring(2, 4), 16);
          const beatB = parseInt(rgbBeat.substring(4, 6), 16);
          for (let ci = 0; ci < clones3d.length; ci++) {
            const clone = clones3d[ci];
            const angle = (clone.index / total) * Math.PI * 2 + time * settings3d.speed;
            // Posición del clon en el círculo
            let cxp = Math.cos(angle) * radius;
            let cyp = 0;
            let czp = Math.sin(angle) * radius;
            // Aplicar viento (rotación en X)
            const wx = settings3d.wind * Math.PI;
            const cosx = Math.cos(wx);
            const sinx = Math.sin(wx);
            const y2 = cyp * cosx - czp * sinx;
            const z2 = cyp * sinx + czp * cosx;
            cyp = y2;
            czp = z2;
            // Procesar cada cara del modelo
            const vList = modelGeometry3d.vertices;
            const fList = modelGeometry3d.faces;
            const scale = settings3d.scale * micMult;
            for (let fi = 0; fi < fList.length; fi++) {
              const face = fList[fi];
              const v1 = vList[face[0]];
              const v2 = vList[face[1]];
              const v3 = vList[face[2]];
              // Calcular posiciones en el mundo
              const w1x = cxp + v1[0] * scale;
              const w1y = cyp + v1[1] * scale;
              const w1z = czp + v1[2] * scale;
              const w2x = cxp + v2[0] * scale;
              const w2y = cyp + v2[1] * scale;
              const w2z = czp + v2[2] * scale;
              const w3x = cxp + v3[0] * scale;
              const w3y = cyp + v3[1] * scale;
              const w3z = czp + v3[2] * scale;
              // Normal del triángulo (usada para sombreado)
              const ux = w2x - w1x;
              const uy = w2y - w1y;
              const uz = w2z - w1z;
              const vx = w3x - w1x;
              const vy = w3y - w1y;
              const vz = w3z - w1z;
              const nx = uy * vz - uz * vy;
              const ny = uz * vx - ux * vz;
              const nz = ux * vy - uy * vx;
              // Evitar caras traseras (culling básico)
              if (nz <= 0) continue;
              const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
              const nzNorm = nz / len;
              // Proyección perspectiva
              const p1 = {};
              const p2 = {};
              const p3 = {};
              const pr1 = d / (w1z + d);
              const pr2 = d / (w2z + d);
              const pr3 = d / (w3z + d);
              p1.x = (w1x * pr1) * 200 + width / 2;
              p1.y = (w1y * pr1) * 200 + height / 2;
              p1.z = w1z;
              p2.x = (w2x * pr2) * 200 + width / 2;
              p2.y = (w2y * pr2) * 200 + height / 2;
              p2.z = w2z;
              p3.x = (w3x * pr3) * 200 + width / 2;
              p3.y = (w3y * pr3) * 200 + height / 2;
              p3.z = w3z;
              // Calcular z medio para ordenar profundidad
              const zAvg = (w1z + w2z + w3z) / 3;
              // Calcular sombreado simple basado en normal z
              const shade = 0.5 + 0.5 * nzNorm;
              let rBase, gBase, bBase;
              if (beat) {
                rBase = beatR;
                gBase = beatG;
                bBase = beatB;
              } else {
                rBase = baseR;
                gBase = baseG;
                bBase = baseB;
              }
              const r = Math.min(255, Math.max(0, Math.round(rBase * shade)));
              const g = Math.min(255, Math.max(0, Math.round(gBase * shade)));
              const b = Math.min(255, Math.max(0, Math.round(bBase * shade)));
              allFaces.push({ p1, p2, p3, z: zAvg, color: `rgb(${r},${g},${b})` });
            }
          }
          // Ordenar caras desde el fondo hacia el frente
          allFaces.sort((a, b) => b.z - a.z);
          allFaces.forEach((f) => {
            ctx.fillStyle = f.color;
            ctx.beginPath();
            ctx.moveTo(f.p1.x, f.p1.y);
            ctx.lineTo(f.p2.x, f.p2.y);
            ctx.lineTo(f.p3.x, f.p3.y);
            ctx.closePath();
            ctx.fill();
          });
        } else {
          // Dibujar esferas simples cuando no hay modelo cargado
          const baseSize = 40 * settings3d.scale;
          const total = Math.max(1, settings3d.count);
          clones3d.forEach((clone) => {
            const angle = (clone.index / total) * Math.PI * 2 + time * settings3d.speed;
            // Posición base
            let x = Math.cos(angle) * radius;
            let y = 0;
            let z = Math.sin(angle) * radius;
            // Aplicar viento (rotación en X)
            const wx = settings3d.wind * Math.PI;
            const cosx = Math.cos(wx);
            const sinx = Math.sin(wx);
            const y2b = y * cosx - z * sinx;
            const z2b = y * sinx + z * cosx;
            y = y2b;
            z = z2b;
            // Ajustar escala por profundidad y micrófono
            const d2 = 6;
            const perspective = d2 / (z + d2);
            const size2d = baseSize * perspective * micMult;
            const px = (x * perspective) * 200 + width / 2;
            const py = (y * perspective) * 200 + height / 2;
            // Color y glow
            const col = beat ? colorBeat : colorNorm;
            const grd = ctx.createRadialGradient(px, py, 0, px, py, size2d);
            const rgb = col.replace('#', '');
            const r = parseInt(rgb.substring(0, 2), 16);
            const g = parseInt(rgb.substring(2, 4), 16);
            const b = parseInt(rgb.substring(4, 6), 16);
            const colorStart = `rgba(${r},${g},${b},1)`;
            const colorEnd = `rgba(${r},${g},${b},0)`;
            grd.addColorStop(0, colorStart);
            grd.addColorStop(1, colorEnd);
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(px, py, size2d, 0, Math.PI * 2);
            ctx.fill();
          });
        }
      }

      // Micrófono
      let micEnabled = false;
      let audioCtx;
      let analyser;
      let dataArray;
      function initMic() {
        if (micEnabled) return;
        navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioCtx.createAnalyser();
          const source = audioCtx.createMediaStreamSource(stream);
          source.connect(analyser);
          analyser.fftSize = 256;
          const bufferLength = analyser.frequencyBinCount;
          dataArray = new Uint8Array(bufferLength);
          micEnabled = true;
        }).catch((err) => {
          console.error('Error al acceder al micrófono:', err);
        });
      }
      function getMicLevel() {
        if (!micEnabled || !analyser) return 0;
        analyser.getByteFrequencyData(dataArray);
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        return sum / dataArray.length / 255;
      }

      // Partículas básicas para modo "esferas"
      class Particle {
        constructor() {
          this.reset();
        }
              reset() {
                // Posición inicial y velocidad se ajustan según la dirección para
                // que las partículas salgan claramente desde el borde
                this.radius = 10 + Math.random() * 20;
                this.life = 0;
                this.ttl = (60 + Math.random() * 80) * settings.height;
                // Reset particles to always originate from the bottom of the canvas
                // and travel straight upward. Random horizontal drift is provided
                // via the turbulence/width settings rather than directional flags.
                const baseVel = (3 + Math.random() * 1.5) * settings.speed;
                this.x = Math.random() * width * settings.width;
                // spawn just below the visible area so particles rise into view
                this.y = height + 80;
                // random horizontal velocity influenced by turbulence
                this.vx = (Math.random() - 0.5) * settings.turb;
                // vertical velocity is always upward (negative)
                this.vy = -baseVel;
              }
        update(micMult) {
          // Update position using stored velocities and global wind. All particles
          // travel upward; horizontal drift is applied via vx and wind.
          this.x += this.vx + wind;
          this.y += this.vy - micMult * 2;
          this.life++;
          if (this.life > this.ttl || this.y < -50) {
            this.reset();
          }
        }
      }

      // Partículas para modo personalizado (usan imagen)
      class CustomParticle {
        constructor() {
          this.reset();
        }
             reset() {
               // Posición inicial y velocidad ajustadas según la dirección
               this.radius = 10 + Math.random() * 20;
               this.life = 0;
               this.ttl = (60 + Math.random() * 80) * settings.height;
               // Custom particles always spawn at the bottom and rise upward.
               const baseVel = (3 + Math.random() * 1.5) * settings.speed;
               this.x = Math.random() * width * settings.width;
               this.y = height + 80;
               this.vx = (Math.random() - 0.5) * settings.turb;
               this.vy = -baseVel;
             }
        update(micMult) {
          // Apply horizontal drift and wind to custom particles as they rise.
          this.x += this.vx + wind * 0.5;
          this.y += this.vy - micMult * 2;
          this.life++;
          if (this.life > this.ttl || this.y < -50) {
            this.reset();
          }
        }
      }

      function initParticles() {
        particles = [];
        for (let i = 0; i < settings.count; i++) {
          particles.push(new Particle());
        }
      }
      function initAbstracts() {
        abstracts = [];
        const n = Math.max(1, Math.floor(settings.count / 4));
        for (let i = 0; i < n; i++) {
          abstracts.push({
            angle: Math.random() * Math.PI * 2,
            radius: Math.random() * Math.min(width, height) * 0.4,
            speed: 0.001 + Math.random() * 0.003,
            size: 5 + Math.random() * 20,
            color: randomColor()
          });
        }
      }
      function initCustom() {
        customParticles = [];
        for (let i = 0; i < settings.count; i++) {
          customParticles.push(new CustomParticle());
        }
      }

      // Devuelve uno de los cuatro colores definidos en los controles
      function randomColor() {
        const cols = [settings.color1, settings.color2, settings.color3, settings.color4];
        return cols[Math.floor(Math.random() * cols.length)];
      }

    // Invertir un color hexadecimal (por ejemplo #ffcc00 -> #0033ff)
    function invertColor(hex) {
      const h = hex.replace('#', '');
      const num = parseInt(h.length === 3 ? h.split('').map((c) => c + c).join('') : h, 16);
      const inv = 0xffffff ^ num;
      return '#' + inv.toString(16).padStart(6, '0');
    }

      function drawParticles(micMult, beat) {
        for (const p of particles) {
          p.update(micMult);
          // Aumentar el tamaño de la partícula según la intensidad del micrófono
          const r = p.radius * settings.size * micMult;
          // Invertir colores en los golpes (beat) y aplicar gradiente de 4 colores
          const cols = [
            beat ? invertColor(settings.color1) : settings.color1,
            beat ? invertColor(settings.color2) : settings.color2,
            beat ? invertColor(settings.color3) : settings.color3,
            beat ? invertColor(settings.color4) : settings.color4
          ];
          // gradiente radial para las esferas con cuatro paradas
          const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * settings.height * settings.glow);
          grad.addColorStop(0, cols[0]);
          grad.addColorStop(0.33, cols[1]);
          grad.addColorStop(0.66, cols[2]);
          grad.addColorStop(1, cols[3] + '00');
          ctx.beginPath();
          ctx.fillStyle = grad;
          ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      function drawAbstract(micMult, beat) {
        const cx = width / 2;
        const cy = height / 2;
        for (const sh of abstracts) {
          sh.angle += sh.speed * settings.speed;
          sh.radius += Math.sin(sh.angle * 0.5) * 0.5;
          // Draw shapes orbiting around the center without directional offsets.
          const x = cx + sh.radius * Math.cos(sh.angle);
          const y = cy + sh.radius * Math.sin(sh.angle);
          const s = sh.size * settings.size * micMult;
          ctx.beginPath();
          const fillCol = beat ? invertColor(sh.color) : sh.color;
          ctx.fillStyle = fillCol;
          ctx.arc(x, y, s, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      // Dibuja las partículas personalizadas (PNG) aplicando reactividad al micrófono.
      // Las imágenes crecen con micMult y se invierten los colores cuando se detecta un "beat".
      function drawCustom(micMult, beat) {
        if (!settings.image) return;
        // Guardar estado del contexto para aislar filtros
        ctx.save();
        // Aplicar filtro de inversión si hay beat
        ctx.filter = beat ? 'invert(1)' : 'none';
        for (const p of customParticles) {
          p.update(micMult);
          // Aumentar tamaño con micMult
          const r = p.radius * settings.size * micMult;
          ctx.drawImage(settings.image, p.x - r, p.y - r, r * 2, r * 2);
        }
        // Restaurar el filtro y el estado del contexto
        ctx.filter = 'none';
        ctx.restore();
      }

      // Inicializar barras (no se necesita precálculo)
      function initBars() {
        // No hay datos persistentes para las barras; se generan dinámicamente durante el dibujo
      }

      // Inicializar el nuevo modo "Líneas". Las líneas orbitan alrededor del
      // centro con diferentes radios y velocidades. El número de líneas se
      // controla mediante el slider de "Cantidad".
      function initLines() {
        lines = [];
        const n = Math.max(1, settings.count);
        const maxRad = Math.min(width, height) * 0.5;
        for (let i = 0; i < n; i++) {
          lines.push({
            angle: Math.random() * Math.PI * 2,
            radius: Math.random() * maxRad,
            speed: (Math.random() - 0.5) * 0.5,
            // Selecciona un color al azar entre los cuatro definidos
            color: randomColor(),
          });
        }
      }

      // Dibuja el visualizador de líneas tipo "spider web". Cada línea
      // conecta dos puntos en el círculo central y reacciona al micrófono
      // cambiando grosor y color en los beats.
      function drawLines(micMult, beat) {
        const cx = width / 2;
        const cy = height / 2;
        const thickness = settings.size * micMult * 2;
        ctx.lineWidth = thickness;
        for (const ln of lines) {
          // Actualizar el ángulo dependiendo de la velocidad y del slider de velocidad
          ln.angle += ln.speed * settings.speed * 0.05;
          const r = ln.radius;
          const x1 = cx + Math.cos(ln.angle) * r;
          const y1 = cy + Math.sin(ln.angle) * r;
          // El segundo punto se calcula con un desfase de 90 grados y una
          // longitud reducida para crear un efecto de tela de araña
          const x2 = cx + Math.cos(ln.angle + Math.PI * 0.5) * r * 0.5;
          const y2 = cy + Math.sin(ln.angle + Math.PI * 0.5) * r * 0.5;
          const col = beat ? invertColor(ln.color) : ln.color;
          ctx.beginPath();
          ctx.strokeStyle = col;
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }

      // Dibujar visualizador de barras al estilo de reproductores clásicos
      function drawBars(micMult, beat) {
        // Recalcular el nivel del micrófono para cada cuadro para mayor precisión
        const micLevelLocal = getMicLevel();
        const n = Math.max(1, settings.count);
        const bw = width / n;
        for (let i = 0; i < n; i++) {
          const t = n === 1 ? 0 : i / (n - 1);
          // Determinar el color interpolando entre los cuatro colores definidos
          let col;
          if (t < 1 / 3) {
            col = lerpColorHex(settings.color1, settings.color2, t * 3);
          } else if (t < 2 / 3) {
            col = lerpColorHex(settings.color2, settings.color3, (t - 1 / 3) * 3);
          } else {
            col = lerpColorHex(settings.color3, settings.color4, (t - 2 / 3) * 3);
          }
          // Determinar altura de la barra basada en el nivel de micrófono y factores de usuario
          // Añadir un valor base (0.05) para que las barras sean visibles incluso sin audio
          // Usamos un factor de escala mayor (400) para que las barras ocupen una parte significativa del lienzo
          // Increase the bar height significantly to make the visual impact stronger
          const amp = (micLevelLocal + 0.05) * settings.height * 800 * (0.5 + Math.random() * 0.5);
          const barHeight = Math.min(height, amp);
          const xPos = i * bw + bw * 0.1;
          const barW = bw * 0.8;
          const yPos = height - barHeight;
          // Invertir color en los beats
          const drawColor = beat ? invertColor3D(col) : col;
          ctx.fillStyle = drawColor;
          ctx.fillRect(xPos, yPos, barW, barHeight);
        }
      }

      function animate() {
        // Ligeramente transparente para crear estela con tema dinámico
        ctx.fillStyle = settings.themeLight ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)';
        ctx.fillRect(0, 0, width, height);

        // Always compute audio values for 2D visualizers
        const micLevel = getMicLevel();
        const micMult = 1 + micLevel * 10 * settings.micSensitivity;
        const beat = micLevel * settings.micSensitivity > 0.12;
        // Draw the appropriate 2D visualizer based on the selected mode
        if (settings.mode === 'spheres') {
          drawParticles(micMult, beat);
        } else if (settings.mode === 'abstract') {
          drawAbstract(micMult, beat);
        } else if (settings.mode === 'custom') {
          drawCustom(micMult, beat);
        } else if (settings.mode === 'bars') {
          drawBars(micMult, beat);
        } else if (settings.mode === 'lines') {
          drawLines(micMult, beat);
        }

        // Ajustar viento objetivo según drift o puntero
        if (!settings.pointerWind) {
          if (settings.drift) {
            const t = Date.now() * 0.0004;
            targetWind = Math.sin(t) * 2;
          } else {
            targetWind = 0;
          }
        }
        // Aplicar interpolación hacia el viento objetivo
        wind += (targetWind - wind) * 0.05;
        // Aplicar viento constante configurado
        wind += settings.windConst * 0.02;

        // Añadir grano/ruido si está activado
        if (settings.grain) {
          ctx.save();
          ctx.fillStyle = settings.themeLight ? 'rgba(0,0,0,0.03)' : 'rgba(255,255,255,0.03)';
          for (let i = 0; i < 300; i++) {
            const gx = Math.random() * width;
            const gy = Math.random() * height;
            ctx.fillRect(gx, gy, 1, 1);
          }
          ctx.restore();
        }
        requestAnimationFrame(animate);
      }

      function initMode() {
        if (settings.mode === 'spheres') {
          initParticles();
        } else if (settings.mode === 'abstract') {
          initAbstracts();
        } else if (settings.mode === 'custom') {
          initCustom();
        } else if (settings.mode === 'bars') {
          initBars();
        } else if (settings.mode === 'lines') {
          initLines();
        }
      }

      function updateSettings() {
        settings.color1 = document.getElementById('color1').value;
        settings.color2 = document.getElementById('color2').value;
        settings.color3 = document.getElementById('color3').value;
        settings.color4 = document.getElementById('color4').value;
        settings.speed = parseFloat(document.getElementById('speed').value);
        settings.height = parseFloat(document.getElementById('height').value);
        settings.width = parseFloat(document.getElementById('width2d').value);
        settings.turb = parseFloat(document.getElementById('turb2d').value);
        settings.count = parseInt(document.getElementById('count').value, 10);
        settings.size = parseFloat(document.getElementById('size').value);
        settings.glow = parseFloat(document.getElementById('glow').value);
        settings.windConst = parseFloat(document.getElementById('windConst').value);
        settings.micSensitivity = parseFloat(document.getElementById('micSens2d').value);
        settings.grain = document.getElementById('grainToggle').checked;
        settings.drift = document.getElementById('driftToggle').checked;
        settings.themeLight = document.getElementById('lightToggle').checked;
        // Reinitialize based on new settings
        initMode();
        // Update canvas background according to theme
        const canvasEl = document.getElementById('canvas2d');
        if (canvasEl) {
          canvasEl.style.backgroundColor = settings.themeLight ? '#ffffff' : '#000000';
        }
      }

      // Actualizar ajustes al mover sliders
      document.getElementById('color1').addEventListener('input', updateSettings);
      document.getElementById('color2').addEventListener('input', updateSettings);
      document.getElementById('color3').addEventListener('input', updateSettings);
      document.getElementById('color4').addEventListener('input', updateSettings);
      document.getElementById('speed').addEventListener('input', updateSettings);
      document.getElementById('height').addEventListener('input', updateSettings);
      document.getElementById('width2d').addEventListener('input', updateSettings);
      document.getElementById('turb2d').addEventListener('input', updateSettings);
      document.getElementById('count').addEventListener('input', updateSettings);
      document.getElementById('size').addEventListener('input', updateSettings);
      document.getElementById('glow').addEventListener('input', updateSettings);
      document.getElementById('windConst').addEventListener('input', updateSettings);
      document.getElementById('micSens2d').addEventListener('input', updateSettings);
      document.getElementById('grainToggle').addEventListener('change', updateSettings);
      document.getElementById('driftToggle').addEventListener('change', updateSettings);
      document.getElementById('lightToggle').addEventListener('change', updateSettings);
      // El selector de dirección se ha eliminado; no se requiere escucha

      // Ajustar resolución (rendimiento) cambiando el factor de densidad de píxeles
      document.getElementById('pixel2d').addEventListener('input', (e) => {
        const v = parseFloat(e.target.value) || 1;
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        // Actualizar ancho y alto del lienzo basados en el nuevo factor de escala
        width = Math.max(1, Math.floor(rect.width * dpr * v));
        height = Math.max(1, Math.floor(rect.height * dpr * v));
        canvas.width = width;
        canvas.height = height;
      });

      // Aleatorizar ajustes y colores del modo 2D
      document.getElementById('randomize2d').addEventListener('click', () => {
        function rc() {
          return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
        }
        document.getElementById('color1').value = rc();
        document.getElementById('color2').value = rc();
        document.getElementById('color3').value = rc();
        document.getElementById('color4').value = rc();
        // Rango de sliders: velocidad 0.5-3, altura 0.5-3, anchura 0.5-3, turbulencia 0-2
        document.getElementById('speed').value = (0.5 + Math.random() * 2.5).toFixed(2);
        document.getElementById('height').value = (0.5 + Math.random() * 2.5).toFixed(2);
        document.getElementById('width2d').value = (0.5 + Math.random() * 2.5).toFixed(2);
        document.getElementById('turb2d').value = (Math.random() * 2).toFixed(2);
        // Cantidad 10-1000, tamaño 5-55 aproximadamente, resplandor 0-3, viento constante -2 a 2
        const countMin = parseInt(document.getElementById('count').min, 10);
        const countMax = parseInt(document.getElementById('count').max, 10);
        document.getElementById('count').value = Math.floor(Math.random() * (countMax - countMin + 1)) + countMin;
        const sizeMin = parseInt(document.getElementById('size').min || '5', 10);
        const sizeMax = parseInt(document.getElementById('size').max || '55', 10);
        document.getElementById('size').value = Math.floor(Math.random() * (sizeMax - sizeMin + 1)) + sizeMin;
        document.getElementById('glow').value = (Math.random() * 3).toFixed(2);
        document.getElementById('windConst').value = (Math.random() * 4 - 2).toFixed(2);
        updateSettings();
      });

      // Compartir configuración actual del modo 2D copiando un enlace a portapapeles
      document.getElementById('share2d').addEventListener('click', async () => {
        const params = new URLSearchParams();
        params.set('v', '2d');
        params.set('m', settings.mode);
        params.set('c1', document.getElementById('color1').value.slice(1));
        params.set('c2', document.getElementById('color2').value.slice(1));
        params.set('c3', document.getElementById('color3').value.slice(1));
        params.set('c4', document.getElementById('color4').value.slice(1));
        params.set('sp', document.getElementById('speed').value);
        params.set('he', document.getElementById('height').value);
        params.set('wi', document.getElementById('width2d').value);
        params.set('tb', document.getElementById('turb2d').value);
        params.set('ct', document.getElementById('count').value);
        params.set('sz', document.getElementById('size').value);
        params.set('gl', document.getElementById('glow').value);
        params.set('wd', document.getElementById('windConst').value);
        params.set('gr', document.getElementById('grainToggle').checked ? '1' : '0');
        params.set('dr', document.getElementById('driftToggle').checked ? '1' : '0');
        params.set('th', document.getElementById('lightToggle').checked ? '1' : '0');
        const url = window.location.origin + window.location.pathname + '#' + params.toString();
        try {
          await navigator.clipboard.writeText(url);
          console.log('Configuración copiada al portapapeles');
        } catch (err) {
          console.error('No se pudo copiar al portapapeles', err);
        }
      });

      // Micrófono toggle
      document.getElementById('micToggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          initMic();
        } else {
          micEnabled = false;
        }
      });

      // Viento táctil toggle
      document.getElementById('windToggle').addEventListener('change', (e) => {
        // Activar o desactivar el viento controlado por el puntero
        settings.pointerWind = e.target.checked;
      });

      // Control de viento con movimiento del ratón
      canvas.addEventListener('mousemove', (e) => {
        if (settings.pointerWind) {
          const relX = e.clientX / width;
          // Mapea la posición horizontal a un rango de viento -2..2
          targetWind = (relX - 0.5) * 4;
        }
      });
      canvas.addEventListener('mouseleave', () => {
        if (settings.pointerWind) {
          targetWind = 0;
        }
      });

      // Carga de imagen personalizada
      document.getElementById('customImage').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (ev) => {
            const img = new Image();
            img.src = ev.target.result;
            img.onload = () => {
              settings.image = img;
              initCustom();
            };
          };
          reader.readAsDataURL(file);
        }
      });

      // --- Controles específicos del modo 3D ---
      // Color del clon
      document.getElementById('color3d').addEventListener('input', (e) => {
        settings3d.color = e.target.value;
        // Update clone colors immediately when the base color changes
        updateCloneColors3d(false);
      });
      // Cargar modelo 3D (OBJ, GLTF o GLB) y ajustar clones
      document.getElementById('modelFile').addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const ext = file.name.split('.').pop().toLowerCase();
        // Soporte OBJ a través de THREE.OBJLoader o fallback al parser incorporado
        if (ext === 'obj') {
          // Si existe OBJLoader (Three.js), usarlo; de lo contrario, usar el parser OBJ simple
          if (typeof THREE !== 'undefined' && THREE.OBJLoader) {
            const reader = new FileReader();
            reader.onload = (evt) => {
              const text = evt.target.result;
              const loader = new THREE.OBJLoader();
              const obj = loader.parse(text);
              window.threeModel = obj;
              centerModel3d();
              init3d();
              // Crear clones con el nuevo modelo
              createClones3d();
            };
            reader.readAsText(file);
          } else {
            const reader = new FileReader();
            reader.onload = (evt) => {
              const text = evt.target.result;
              const geom = parseOBJ(text);
              if (geom) {
                modelGeometry3d = geom;
                window.threeModel = null;
                init3d();
                // Crear clones con el modelo cargado cuando se usa el parser simple
                createClones3d();
              } else {
                console.error('No se pudo cargar el modelo. Asegúrate de que sea un OBJ válido.');
                modelGeometry3d = null;
              }
            };
            reader.readAsText(file);
          }
        } else {
          // Para GLTF/GLB usar GLTFLoader si está disponible
          if (typeof THREE !== 'undefined' && THREE.GLTFLoader) {
            const reader = new FileReader();
            reader.onload = (evt) => {
              const arrayBuffer = evt.target.result;
              const loader = new THREE.GLTFLoader();
              loader.parse(arrayBuffer, '', (gltf) => {
                window.threeModel = gltf.scene;
                centerModel3d();
                init3d();
                // Crear clones con el nuevo modelo
                createClones3d();
              }, (error) => {
                console.error('Error al cargar GLTF/GLB:', error);
              });
            };
            reader.readAsArrayBuffer(file);
          } else {
            console.error('GLTFLoader no disponible, el modelo GLB no se puede cargar');
          }
        }
      });
      // Número de clones
      document.getElementById('count3d').addEventListener('input', (e) => {
        settings3d.count = parseInt(e.target.value, 10) || 1;
        init3d();
        // Recreate clones with new count
        if (typeof THREE !== 'undefined') createClones3d();
      });
      // Escala base
      document.getElementById('scale3d').addEventListener('input', (e) => {
        settings3d.scale = parseFloat(e.target.value);
      });
      // Velocidad de rotación
      document.getElementById('speed3d').addEventListener('input', (e) => {
        settings3d.speed = parseFloat(e.target.value);
      });
      // Separación/radio
      document.getElementById('spread3d').addEventListener('input', (e) => {
        settings3d.spread = parseFloat(e.target.value);
        init3d();
        // No need to recreate clones; spacing is handled in draw3d via position update
      });
      // Micrófono para 3D
      document.getElementById('mic3d').addEventListener('change', (e) => {
        if (e.target.checked) {
          initMic3d();
        } else {
          micOn3d = false;
        }
      });
      // Sensibilidad del micrófono
      document.getElementById('micSens3d').addEventListener('input', (e) => {
        settings3d.micSensitivity = parseFloat(e.target.value);
      });
      // Viento (rotación en X)
      document.getElementById('wind3d').addEventListener('input', (e) => {
        settings3d.wind = parseFloat(e.target.value);
      });
      // Auto drift en 3D
      document.getElementById('drift3d').addEventListener('change', (e) => {
        settings3d.drift = e.target.checked;
      });
      // Tema claro en 3D
      document.getElementById('light3d').addEventListener('change', (e) => {
        settings3d.themeLight = e.target.checked;
        // Cambiar color de fondo del lienzo acorde al tema
        document.getElementById('canvas2d').style.backgroundColor = settings3d.themeLight ? '#ffffff' : '#000000';
        // Actualizar color de fondo del renderer de Three.js si está inicializado
        if (typeof THREE !== 'undefined' && threeRenderer) {
          threeRenderer.setClearColor(settings3d.themeLight ? 0xffffff : 0x000000, 1);
        }
      });
      // Ocultar y mostrar panel en 3D
      document.getElementById('hidePanel3d').addEventListener('click', () => {
        document.getElementById('controls3d').style.display = 'none';
        document.getElementById('controls3dCollapsed').style.display = 'block';
        const brand = document.getElementById('branding');
        if (brand) brand.style.display = 'none';
      });
      document.getElementById('showPanel3d').addEventListener('click', () => {
        document.getElementById('controls3d').style.display = 'block';
        document.getElementById('controls3dCollapsed').style.display = 'none';
        const brand = document.getElementById('branding');
        if (brand) brand.style.display = 'block';
      });

      // -------------------------------------------------------------------
      // Three.js based 3D rendering
      // Variables for Three.js scene, camera, renderer and group of clones
      let threeScene = null;
      let threeCamera = null;
      let threeRenderer = null;
      let threeGroup = null;
      let threeInitialized = false;

      // Ensure Three.js scene and renderer are created
      function setupThree() {
        if (threeInitialized) return;
        const container = document.getElementById('threeContainer');
        const w = container.clientWidth || window.innerWidth;
        const h = container.clientHeight || window.innerHeight;
        threeRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        threeRenderer.setSize(w, h);
        container.innerHTML = '';
        container.appendChild(threeRenderer.domElement);
        threeScene = new THREE.Scene();
        threeCamera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
        threeCamera.position.set(0, 0, 10);
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        threeScene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 7);
        threeScene.add(dirLight);
        threeGroup = new THREE.Group();
        threeScene.add(threeGroup);
        threeInitialized = true;
      }

      // Center and normalize a loaded model (scale to unit size and center at origin)
      function centerModel3d() {
        if (!window.threeModel) return;
        const box = new THREE.Box3().setFromObject(window.threeModel);
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const scale = 1 / maxDim;
        window.threeModel.scale.set(scale, scale, scale);
        box.setFromObject(window.threeModel);
        const center = box.getCenter(new THREE.Vector3());
        window.threeModel.position.sub(center);
      }

      // Create clones based on loaded model or default sphere
      function createClones3d() {
        setupThree();
        if (!threeGroup) return;
        threeGroup.clear();
        const total = Math.max(1, settings3d.count);
        if (window.threeModel) {
          for (let i = 0; i < total; i++) {
            const clone = window.threeModel.clone();
            clone.traverse((child) => {
              if (child.material) child.material = child.material.clone();
            });
            clone.userData.index = i;
            threeGroup.add(clone);
          }
        } else {
          // Default to simple spheres using Three.js if no model is loaded
          const geometry = new THREE.SphereGeometry(1, 16, 16);
          for (let i = 0; i < total; i++) {
            // Use a standard material to allow lighting and shading
            const material = new THREE.MeshStandardMaterial({ color: new THREE.Color(settings3d.color) });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData.index = i;
            threeGroup.add(mesh);
          }
        }
      }

      // Apply color inversion on beat
      function updateCloneColors3d(invert) {
        // Only update colors for meshes without textures. If the material has a map
        // (texture) we respect the original imported appearance. This allows GLB
        // models to retain their materials and textures. For simple meshes (like
        // default spheres) we override the color and apply inversion on beats.
        if (!threeGroup) return;
        const targetColor = invert ? invertColor3D(settings3d.color) : settings3d.color;
        threeGroup.traverse((child) => {
          if (child.material && child.material.color) {
            // Skip materials that use a texture map; they already define color via the texture
            if (child.material.map) return;
            child.material.color.set(targetColor);
          }
        });
      }

      // Override draw3d to use Three.js renderer when available
      function draw3d(micMult, beat) {
        if (threeGroup && threeRenderer) {
          const time = Date.now() * 0.001;
          const radius = settings3d.spread;
          const total = Math.max(1, settings3d.count);
          threeGroup.children.forEach((clone) => {
            const idx = clone.userData.index || 0;
            const angle = (idx / total) * Math.PI * 2 + time * settings3d.speed;
            clone.position.x = Math.cos(angle) * radius;
            clone.position.z = Math.sin(angle) * radius;
            clone.rotation.x = settings3d.wind * Math.PI;
            const scaleFactor = settings3d.scale * (1 + micMult * settings3d.micSensitivity * 2);
            clone.scale.set(scaleFactor, scaleFactor, scaleFactor);
          });
          updateCloneColors3d(beat);
          // Background color according to theme
          if (threeRenderer) {
            threeRenderer.setClearColor(settings3d.themeLight ? 0xffffff : 0x000000, 1);
            threeRenderer.render(threeScene, threeCamera);
          }
          return;
        }
        // fallback: if Three.js not initialized use existing custom 3D engine (no-op)
      }

      // Ocultar y mostrar panel en 2D
      document.getElementById('hidePanel2d').addEventListener('click', () => {
        document.getElementById('controls2d').style.display = 'none';
        document.getElementById('controls2dCollapsed').style.display = 'block';
        // Ocultar también la marca cuando se oculta el panel
        const brand = document.getElementById('branding');
        if (brand) brand.style.display = 'none';
      });
      document.getElementById('showPanel2d').addEventListener('click', () => {
        document.getElementById('controls2d').style.display = 'block';
        document.getElementById('controls2dCollapsed').style.display = 'none';
        // Mostrar la marca al volver a mostrar el panel
        const brand = document.getElementById('branding');
        if (brand) brand.style.display = 'block';
      });

      // Inicializar y arrancar animación
      initMode();
      animate();

      // Exponer función global para cambiar el modo
      window._update2dMode = function(mode) {
        settings.mode = mode;
        if (mode === 'custom') {
          document.getElementById('customImageWrapper').style.display = 'block';
          initCustom();
        } else {
          document.getElementById('customImageWrapper').style.display = 'none';
          initMode();
        }
      };

      // Exponer inicializador para modo 3D para ser llamado desde el selector de modo
      window.init3d = init3d;
    })();



    // Selección global de modos y montaje/desmontaje de React
    (function() {
      const modeSelect = document.getElementById('modeSelect');
      let isReactMounted = false;
      // 3D manual engine no necesita un flag de montaje
      modeSelect.addEventListener('change', function(e) {
        const mode = e.target.value;
        if (mode === 'original') {
          // Mostrar llama WebGL y ocultar otros modos
          document.getElementById('threeContainer').style.display = 'none';
          document.getElementById('controls3d').style.display = 'none';
          document.getElementById('controls3dCollapsed').style.display = 'none';
          document.getElementById('canvas2d').style.display = 'none';
          document.getElementById('controls2d').style.display = 'none';
          document.getElementById('controls2dCollapsed').style.display = 'none';
          document.getElementById('flame-wrapper').style.display = 'block';
          if (!isReactMounted) {
            ReactDOM.render(React.createElement(EternalFlameCanvas), document.getElementById('flame-wrapper'));
            isReactMounted = true;
          }
        } else if (mode === '3d') {
          // Mostrar modo 3D utilizando Three.js
          document.getElementById('flame-wrapper').style.display = 'none';
          // Ocultar controles de 2D
          document.getElementById('controls2d').style.display = 'none';
          document.getElementById('controls2dCollapsed').style.display = 'none';
          // Ocultar lienzo 2D
          document.getElementById('canvas2d').style.display = 'none';
          // Mostrar contenedor de Three.js
          document.getElementById('threeContainer').style.display = 'block';
          // Mostrar panel de 3D y ocultar panel colapsado
          document.getElementById('controls3dCollapsed').style.display = 'none';
          document.getElementById('controls3d').style.display = 'block';
          // Cambiar a modo 3D dentro del motor 2D/3D
          window._update2dMode('3d');
          // Inicializar clones 3D y recrear clones
          if (typeof window.init3d === 'function') {
            window.init3d();
          }
          if (typeof THREE !== 'undefined') {
            createClones3d();
          }
        } else {
          // Mostrar modos 2D (spheres, abstract, custom)
          document.getElementById('flame-wrapper').style.display = 'none';
          document.getElementById('threeContainer').style.display = 'none';
          document.getElementById('controls3d').style.display = 'none';
          document.getElementById('controls3dCollapsed').style.display = 'none';
          document.getElementById('canvas2d').style.display = 'block';
          // Al cambiar a 2D, mostrar panel principal
          document.getElementById('controls2d').style.display = 'block';
          document.getElementById('controls2dCollapsed').style.display = 'none';
          window._update2dMode(mode);
        }
      });
      // Inicialización al cargar
      if (modeSelect.value === 'original') {
        document.getElementById('threeContainer').style.display = 'none';
        document.getElementById('controls3d').style.display = 'none';
        document.getElementById('controls3dCollapsed').style.display = 'none';
        document.getElementById('canvas2d').style.display = 'none';
        document.getElementById('controls2d').style.display = 'none';
        document.getElementById('controls2dCollapsed').style.display = 'none';
        document.getElementById('flame-wrapper').style.display = 'block';
        ReactDOM.render(React.createElement(EternalFlameCanvas), document.getElementById('flame-wrapper'));
        isReactMounted = true;
      } else {
        // Mostrar modos 2D (esferas, abstracto, personalizado, barras)
        document.getElementById('flame-wrapper').style.display = 'none';
        // Ocultar el contenedor Three.js y sus paneles, ya que el modo 3D se ha eliminado
        document.getElementById('threeContainer').style.display = 'none';
        document.getElementById('controls3d').style.display = 'none';
        document.getElementById('controls3dCollapsed').style.display = 'none';
        document.getElementById('canvas2d').style.display = 'block';
        document.getElementById('controls2d').style.display = 'block';
        document.getElementById('controls2dCollapsed').style.display = 'none';
        // Inicializa el modo 2D seleccionado (incluyendo 'custom' y 'bars')
        window._update2dMode(modeSelect.value);
      }
    })();
  </script>
</body>
</html>