<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Visualizador de llamas – Múltiples modos</title>
  <!-- Tailwind para estilos básicos y UI cohesiva -->
  <script src="https://cdn.tailwindcss.com/3.3.5"></script>
  <style>
    /* Oculta temporalmente los contenedores según el modo */
    #flame-wrapper,
    #canvas2d {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    /* Panel de controles para modos 2D (esferas/abstracto) */
    #controls2d label {
      font-size: 12px;
    }
    #controls2d input[type="color"],
    #controls2d input[type="range"],
    #controls2d select,
    #controls2d input[type="checkbox"] {
      margin-left: 4px;
    }
  </style>
</head>
<body class="bg-black text-white">
  <!-- Selector de modo global -->
  <div class="absolute top-2 left-2 z-20 bg-black/70 backdrop-blur px-3 py-2 rounded-lg border border-white/20">
    <label class="text-sm font-medium mr-2">Modo:</label>
    <select id="modeSelect" class="bg-black/60 text-white rounded-md border border-white/30 px-2 py-1">
      <option value="original">Original</option>
      <option value="spheres" selected>Esferas</option>
      <option value="abstract">Abstracto</option>
      <option value="custom">Personalizado</option>
      <option value="3d">3D</option>
    </select>
  </div>

  <!-- Contenedor para el modo "original" (WebGL + React) -->
  <div id="flame-wrapper" style="display:none;"></div>

  <!-- Lienzo para modos 2D (esferas y abstracto) -->
  <canvas id="canvas2d"></canvas>

  <!-- Panel de control para modos 2D -->
  <div id="controls2d" class="absolute top-12 left-2 z-20 bg-black/70 backdrop-blur px-4 py-3 rounded-lg border border-white/20 w-64" style="display:block;">
    <div class="mb-2">
      <label>Color 1
        <input type="color" id="color1" class="align-middle" value="#fdcc0d" />
      </label>
    </div>
    <div class="mb-2">
      <label>Color 2
        <input type="color" id="color2" class="align-middle" value="#32527b" />
      </label>
    </div>
    <div class="mb-2">
      <label>Velocidad
        <input type="range" id="speed" min="0.5" max="3" step="0.1" value="1" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Altura
        <input type="range" id="height" min="0.5" max="3" step="0.1" value="1" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Anchura
        <input type="range" id="width2d" min="0.5" max="3" step="0.1" value="1" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Turbulencia
        <input type="range" id="turb2d" min="0" max="2" step="0.1" value="0" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Cantidad
        <input type="range" id="count" min="10" max="1000" step="10" value="200" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Tamaño
        <input type="range" id="size" min="0.5" max="3" step="0.1" value="1" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Resplandor
        <input type="range" id="glow" min="0" max="5" step="0.1" value="1" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Viento constante
        <input type="range" id="windConst" min="-2" max="2" step="0.1" value="0" class="w-36" />
      </label>
    </div>
    <div class="mb-2" id="customImageWrapper" style="display:none;">
      <label>Imagen
        <input type="file" id="customImage" accept="image/png" class="align-middle" />
      </label>
    </div>
    <div class="mb-2">
      <label>Micrófono
        <input type="checkbox" id="micToggle" class="align-middle" />
      </label>
    </div>
    <div class="mb-2">
      <label>Sensib. mic
        <input type="range" id="micSens2d" min="0" max="2" step="0.1" value="1" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Viento táctil
        <input type="checkbox" id="windToggle" class="align-middle" />
      </label>
    </div>
    <div class="mb-2">
      <label>Granulado
        <input type="checkbox" id="grainToggle" class="align-middle" />
      </label>
    </div>
    <div class="mb-2">
      <label>Auto drift
        <input type="checkbox" id="driftToggle" class="align-middle" />
      </label>
    </div>
    <div class="mb-2">
      <label>Tema claro
        <input type="checkbox" id="lightToggle" class="align-middle" />
      </label>
    </div>
    <div class="mb-2">
      <button id="hidePanel2d" class="text-xs rounded-lg px-3 py-1 border border-white/10 bg-white/10 hover:bg-white/20">Ocultar panel</button>
    </div>
  </div>
  <div id="controls2dCollapsed" class="absolute top-12 left-2 z-20" style="display:none;">
    <button id="showPanel2d" class="text-xs rounded-lg px-3 py-1 border border-white/10 bg-white/10 hover:bg-white/20">Mostrar panel</button>
  </div>

  <!-- Contenedor para modo 3D y su panel de control -->
  <div id="threeContainer" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%;"></div>
  <div id="controls3d" class="absolute top-12 right-2 z-20 bg-black/70 backdrop-blur px-4 py-3 rounded-lg border border-white/20 w-64" style="display:none;">
    <div class="mb-2">
      <label>Modelo
        <input type="file" id="modelFile" accept=".glb,.gltf,.obj" class="align-middle" />
      </label>
    </div>
    <div class="mb-2">
      <label>Color
        <input type="color" id="color3d" class="align-middle" value="#ffffff" />
      </label>
    </div>
    <div class="mb-2">
      <label>Clones
        <input type="range" id="count3d" min="1" max="50" step="1" value="1" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Escala
        <input type="range" id="scale3d" min="0.1" max="3" step="0.1" value="1" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Vel. rotación
        <input type="range" id="speed3d" min="-3" max="3" step="0.05" value="1" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Separación
        <input type="range" id="spread3d" min="0" max="10" step="0.2" value="2" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Micrófono
        <input type="checkbox" id="mic3d" class="align-middle" />
      </label>
    </div>
    <div class="mb-2">
      <label>Sensib. mic
        <input type="range" id="micSens3d" min="0" max="2" step="0.1" value="1" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Viento
        <input type="range" id="wind3d" min="-2" max="2" step="0.1" value="0" class="w-36" />
      </label>
    </div>
    <div class="mb-2">
      <label>Auto drift
        <input type="checkbox" id="drift3d" class="align-middle" />
      </label>
    </div>
    <div class="mb-2">
      <label>Tema claro
        <input type="checkbox" id="light3d" class="align-middle" />
      </label>
    </div>
    <div class="mb-2">
      <button id="hidePanel3d" class="text-xs rounded-lg px-3 py-1 border border-white/10 bg-white/10 hover:bg-white/20">Ocultar panel</button>
    </div>
    <div id="controls3dCollapsed" style="display:none;">
      <button id="showPanel3d" class="text-xs rounded-lg px-3 py-1 border border-white/10 bg-white/10 hover:bg-white/20">Mostrar panel</button>
    </div>
  </div>

  <!-- Librerías para 3D (Three.js y GLTFLoader) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/loaders/GLTFLoader.js"></script>

  <!-- React y Babel para el modo "original" -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    /*
     * Código de React para el modo "original". Utiliza el componente EternalFlameCanvas
     * del visualizador WebGL avanzado, conservando todos los controles y presets.
     * Este código se ejecuta cuando el modo seleccionado es "original".
     */

    // Funciones utilitarias
    function hexToRgb(hex) {
      let h = hex.replace('#', '');
      if (h.length === 3) h = h.split('').map((c) => c + c).join('');
      const num = parseInt(h, 16);
      return [((num >> 16) & 255) / 255, ((num >> 8) & 255) / 255, (num & 255) / 255];
    }
    function rgbToHex(rgb) {
      return (
        '#' +
        rgb
          .map((v) => Math.round(v * 255).toString(16).padStart(2, '0'))
          .join('')
      );
    }
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
    const lerp = (a, b, t) => a + (b - a) * t;

    // Presets de colores y parámetros (incluyendo preset Spatialgineers)
    const PRESETS = {
      classic: {
        cBase: '#3a0d00',
        cMid: '#fd6a00',
        cHot: '#ffd26a',
        cBg: '#000000',
        speed: 1.0,
        turb: 1.0,
        height: 1.2,
        width: 1.4,
        contrast: 1.4,
        glow: 0.6,
        wind: 0.3,
        detail: 5,
      },
      blue: {
        cBase: '#002033',
        cMid: '#1e7fdd',
        cHot: '#a8d7ff',
        cBg: '#00040a',
        speed: 0.9,
        turb: 1.1,
        height: 1.4,
        width: 1.2,
        contrast: 1.6,
        glow: 0.9,
        wind: 0.2,
        detail: 6,
      },
      neon: {
        cBase: '#3a0066',
        cMid: '#ff00e5',
        cHot: '#fdcc0d',
        cBg: '#020008',
        speed: 1.2,
        turb: 1.3,
        height: 1.1,
        width: 1.6,
        contrast: 1.2,
        glow: 1.2,
        wind: 0.5,
        detail: 5,
      },
      brand: {
        cBase: '#0a1622',
        cMid: '#32527b',
        cHot: '#fdcc0d',
        cBg: '#000000',
        speed: 1.0,
        turb: 1.2,
        height: 1.3,
        width: 1.5,
        contrast: 1.3,
        glow: 1.0,
        wind: 0.25,
        detail: 6,
      },
    };

    // Componente principal: EternalFlameCanvas
    function EternalFlameCanvas() {
      const containerRef = React.useRef(null);
      const canvasRef = React.useRef(null);
      const glRef = React.useRef(null);
      const programRef = React.useRef(null);
      const uniformsRef = React.useRef({});
      const rafRef = React.useRef(0);
      const t0Ref = React.useRef(performance.now());
      const lastTRef = React.useRef(performance.now());
      const dprRef = React.useRef(1);
      const micRef = React.useRef({ ctx: null, analyser: null, data: null, on: false, env: 0, sensitivity: 1 });
      const stateRef = React.useRef({
        base: hexToRgb(PRESETS.classic.cBase),
        mid: hexToRgb(PRESETS.classic.cMid),
        hot: hexToRgb(PRESETS.classic.cHot),
        bg: hexToRgb(PRESETS.classic.cBg),
        speed: PRESETS.classic.speed,
        turb: PRESETS.classic.turb,
        height: PRESETS.classic.height,
        width: PRESETS.classic.width,
        contrast: PRESETS.classic.contrast,
        glow: PRESETS.classic.glow,
        wind: PRESETS.classic.wind,
        detail: PRESETS.classic.detail,
        grain: 1.0,
        pixel: 1.0,
        drift: true,
        seed: Math.random() * 1000,
        audio: 0.0,
        touchWind: false,
        themeLight: false,
      });

      const [ui, setUi] = React.useState({
        ...PRESETS.classic,
        cBase: PRESETS.classic.cBase,
        cMid: PRESETS.classic.cMid,
        cHot: PRESETS.classic.cHot,
        cBg: PRESETS.classic.cBg,
        grain: true,
        drift: true,
        pixel: 1.0,
        micReactive: false,
        micSensitivity: 1.0,
        touchWind: false,
        themeLight: false,
        fps: '—',
        panelOpen: true,
      });

      const [toast, setToast] = React.useState('');
      React.useEffect(() => {
        if (!toast) return;
        const id = setTimeout(() => setToast(''), 1600);
        return () => clearTimeout(id);
      }, [toast]);

      // Construye y compila shaders
      function makeProgram(gl) {
        const vsSrc = `
          attribute vec2 a_position;
          varying vec2 v_uv;
          void main(){
            v_uv = a_position * 0.5 + 0.5;
            gl_Position = vec4(a_position, 0.0, 1.0);
          }
        `;
        const fsSrc = `
          precision mediump float;
          varying vec2 v_uv;
          uniform vec2 u_res;
          uniform float u_time;
          uniform float u_seed;
          uniform vec3 u_base;
          uniform vec3 u_mid;
          uniform vec3 u_hot;
          uniform vec3 u_bg;
          uniform float u_speed;
          uniform float u_turb;
          uniform float u_height;
          uniform float u_width;
          uniform float u_contrast;
          uniform float u_glow;
          uniform float u_wind;
          uniform int   u_detail;
          uniform float u_grain;
          uniform float u_audio;

          float hash21(vec2 p){
            p = fract(p*vec2(123.34,345.45));
            p += dot(p,p+34.345);
            return fract(p.x*p.y);
          }
          float noise(vec2 p){
            vec2 i = floor(p);
            vec2 f = fract(p);
            float a = hash21(i);
            float b = hash21(i+vec2(1.,0.));
            float c = hash21(i+vec2(0.,1.));
            float d = hash21(i+vec2(1.,1.));
            vec2 u = f*f*(3.-2.*f);
            return mix(a,b,u.x) + (c-a)*u.y*(1.-u.x) + (d-b)*u.x*u.y;
          }
          mat2 rot(float a){ float s=sin(a), c=cos(a); return mat2(c,-s,s,c); }
          float fbm(vec2 p, int oct){
            float v=0.; float a=0.5;
            for(int i=0;i<8;i++){
              if(i>=oct) break;
              v += a*noise(p);
              p = rot(0.5)*p*2.0 + 10.0;
              a *= 0.5;
            }
            return v;
          }
          vec3 palette(float t, vec3 c1, vec3 c2, vec3 c3){
            float m1 = smoothstep(0.,0.6,t);
            float m2 = smoothstep(0.3,1.,t);
            vec3 c = mix(c1,c2,m1);
            c = mix(c,c3,m2);
            return c;
          }
          void main(){
            vec2 uv = v_uv;
            float aspect = u_res.x/u_res.y;
            vec2 p = vec2((uv.x-0.5)*aspect, uv.y);

            float t = u_time * (0.3 + u_speed*0.7) * (1.0 + u_audio*0.35);
            vec2 seed = vec2(u_seed, u_seed*1.618);

            vec2 q = vec2(
              fbm(p*2.0 + vec2(0.0, t*1.2) + seed, u_detail),
              fbm(p*2.0 + vec2(5.2, t*1.2) - seed, u_detail)
            );
            vec2 r = vec2(
              fbm(p*3.0 + (u_turb + u_audio*0.6)*q + vec2(1.7, t*1.7) + seed*2.0, u_detail),
              fbm(p*3.0 + (u_turb + u_audio*0.6)*q + vec2(9.2, t*1.7) - seed*2.0, u_detail)
            );

            float flameWidth = u_width;
            float flameShape = 1.0 - (abs(p.x*flameWidth) + (1.0-uv.y)*(u_height - u_audio*0.5));
            flameShape = smoothstep(-1.2, 0.5, flameShape);

            float n = fbm(p*2.0 + r*1.2 + vec2((u_wind + u_audio*0.2)*t*0.3, -t*2.0), u_detail);
            n = pow(clamp(n,0.0,1.0), 1.2);

            float intensity = clamp(n*flameShape, 0.0, 1.0);
            intensity = pow(intensity, u_contrast) * (1.0 + u_audio*0.4);

            vec3 col = mix(u_bg, palette(intensity, u_base, u_mid, u_hot), intensity);
            float glow = smoothstep(0.0, 0.8, intensity) * (u_glow + u_audio*1.0);
            col += glow * vec3(1.0, 0.7, 0.3);

            if(u_grain > 0.5){
              float g = hash21(uv*u_res.xy + fract(t))*0.04;
              col += g;
            }
            gl_FragColor = vec4(col,1.0);
          }
        `;

        function compile(src, type) {
          const sh = gl.createShader(type);
          gl.shaderSource(sh, src);
          gl.compileShader(sh);
          if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
            throw new Error('Shader error: ' + gl.getShaderInfoLog(sh));
          }
          return sh;
        }

        const vs = compile(vsSrc, gl.VERTEX_SHADER);
        const fs = compile(fsSrc, gl.FRAGMENT_SHADER);
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          throw new Error('Link error: ' + gl.getProgramInfoLog(prog));
        }
        gl.useProgram(prog);

        const attribPos = gl.getAttribLocation(prog, 'a_position');
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([-1, -1, 3, -1, -1, 3]),
          gl.STATIC_DRAW
        );
        gl.enableVertexAttribArray(attribPos);
        gl.vertexAttribPointer(attribPos, 2, gl.FLOAT, false, 0, 0);

        const U = (name) => gl.getUniformLocation(prog, name);
        uniformsRef.current = {
          u_res: U('u_res'),
          u_time: U('u_time'),
          u_seed: U('u_seed'),
          u_base: U('u_base'),
          u_mid: U('u_mid'),
          u_hot: U('u_hot'),
          u_bg: U('u_bg'),
          u_speed: U('u_speed'),
          u_turb: U('u_turb'),
          u_height: U('u_height'),
          u_width: U('u_width'),
          u_contrast: U('u_contrast'),
          u_glow: U('u_glow'),
          u_wind: U('u_wind'),
          u_detail: U('u_detail'),
          u_grain: U('u_grain'),
          u_audio: U('u_audio'),
        };

        return prog;
      }

      // Resize observer
      React.useEffect(() => {
        const container = containerRef.current;
        const canvas = canvasRef.current;
        if (!container || !canvas) return;
        const gl = (glRef.current = canvas.getContext('webgl', {
          antialias: false,
          alpha: false,
          depth: false,
          stencil: false,
          preserveDrawingBuffer: false,
        }));
        if (!gl) return;
        programRef.current = makeProgram(gl);
        const resizeToContainer = () => {
          const rect = container.getBoundingClientRect();
          const targetDpr = clamp((window.devicePixelRatio || 1) * stateRef.current.pixel, 0.5, 2.0);
          dprRef.current = targetDpr;
          const w = Math.max(1, Math.floor(rect.width * targetDpr));
          const h = Math.max(1, Math.floor(rect.height * targetDpr));
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
            gl.viewport(0, 0, w, h);
          }
        };
        const ro = new ResizeObserver(resizeToContainer);
        ro.observe(container);
        resizeToContainer();

        let frames = 0;
        let fpsAcc = 0;
        const draw = (now) => {
          const U = uniformsRef.current;
          const gl = glRef.current;
          if (!gl) return;
          // Drift y glow
          if (stateRef.current.drift) {
            const tt = (now - t0Ref.current) / 1000;
            targetWindRef.current = lerp(targetWindRef.current, Math.sin(tt * 0.15 + stateRef.current.seed) * 0.6, 0.02);
            stateRef.current.glow = lerp(stateRef.current.glow, 0.8 + Math.sin(tt * 0.25) * 0.4, 0.02);
          }
          // Ease wind
          stateRef.current.wind = lerp(stateRef.current.wind, targetWindRef.current, 0.08);
          // Mic envelope
          stateRef.current.audio = micEnvelope();
          gl.uniform2f(U.u_res, canvas.width, canvas.height);
          gl.uniform1f(U.u_time, (now - t0Ref.current) / 1000);
          gl.uniform1f(U.u_seed, stateRef.current.seed);
          gl.uniform3f(U.u_base, ...stateRef.current.base);
          gl.uniform3f(U.u_mid, ...stateRef.current.mid);
          gl.uniform3f(U.u_hot, ...stateRef.current.hot);
          gl.uniform3f(U.u_bg, ...stateRef.current.bg);
          gl.uniform1f(U.u_speed, stateRef.current.speed);
          gl.uniform1f(U.u_turb, stateRef.current.turb);
          gl.uniform1f(U.u_height, stateRef.current.height);
          gl.uniform1f(U.u_width, stateRef.current.width);
          gl.uniform1f(U.u_contrast, stateRef.current.contrast);
          gl.uniform1f(U.u_glow, stateRef.current.glow);
          gl.uniform1f(U.u_wind, stateRef.current.wind);
          gl.uniform1i(U.u_detail, stateRef.current.detail);
          gl.uniform1f(U.u_grain, stateRef.current.grain);
          gl.uniform1f(U.u_audio, stateRef.current.audio);
          gl.drawArrays(gl.TRIANGLES, 0, 3);
          const dt = now - lastTRef.current;
          lastTRef.current = now;
          frames++;
          fpsAcc += dt;
          if (fpsAcc >= 500) {
            const fps = Math.round((frames * 1000) / fpsAcc);
            setUi((u) => ({ ...u, fps: String(fps) }));
            frames = 0;
            fpsAcc = 0;
          }
          rafRef.current = requestAnimationFrame(draw);
        };
        rafRef.current = requestAnimationFrame(draw);
        return () => {
          cancelAnimationFrame(rafRef.current);
          ro.disconnect();
        };
      }, []);

      // Pointer-driven wind para React
      const lastPointerX = React.useRef(null);
      const targetWindRef = React.useRef(0.3);
      React.useEffect(() => {
        function onMove(e) {
          if (!stateRef.current.touchWind) return;
          const x = e.touches ? e.touches[0].clientX : e.clientX;
          if (lastPointerX.current == null) {
            lastPointerX.current = x;
            return;
          }
          const dx = x - lastPointerX.current;
          lastPointerX.current = x;
          const norm = clamp(dx / window.innerWidth, -1, 1);
          targetWindRef.current = clamp(stateRef.current.wind + norm * 1.2, -2, 2);
        }
        function onUp() {
          lastPointerX.current = null;
        }
        window.addEventListener('pointermove', onMove, { passive: true });
        window.addEventListener('touchmove', onMove, { passive: true });
        window.addEventListener('pointerup', onUp, { passive: true });
        window.addEventListener('touchend', onUp, { passive: true });
        return () => {
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('touchmove', onMove);
          window.removeEventListener('pointerup', onUp);
          window.removeEventListener('touchend', onUp);
        };
      }, []);

      // Mic reactivity
      async function initMic() {
        try {
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          const src = ctx.createMediaStreamSource(stream);
          const analyser = ctx.createAnalyser();
          analyser.fftSize = 1024;
          src.connect(analyser);
          micRef.current = {
            ctx,
            analyser,
            data: new Uint8Array(analyser.frequencyBinCount),
            on: true,
            env: 0,
            sensitivity: ui.micSensitivity,
          };
          setToast('Mic on');
          setUi((u) => ({ ...u, micReactive: true }));
        } catch (e) {
          setToast('Mic blocked/unavailable');
          setUi((u) => ({ ...u, micReactive: false }));
        }
      }
      function micEnvelope() {
        const m = micRef.current;
        if (!m || !m.analyser || !ui.micReactive) return 0;
        m.analyser.getByteFrequencyData(m.data);
        const bins = Math.min(40, m.data.length);
        let sum = 0;
        for (let i = 1; i < bins; i++) sum += m.data[i];
        let avg = sum / bins / 255;
        // Amplificar la señal de audio para mayor reactividad (factor aumentado)
        avg *= 6.0;
        m.env = lerp(m.env, avg, 0.25);
        // Ajustar el límite máximo para permitir más efecto visual
        return clamp(m.env * (m.sensitivity || 1), 0, 4.0);
      }

      // Share link
      const shareLink = async () => {
        const sr = stateRef.current;
        const params = new URLSearchParams({
          v: 'canvas',
          c1: rgbToHex(sr.base).slice(1),
          c2: rgbToHex(sr.mid).slice(1),
          c3: rgbToHex(sr.hot).slice(1),
          cb: rgbToHex(sr.bg).slice(1),
          sp: sr.speed.toFixed(2),
          tb: sr.turb.toFixed(2),
          he: sr.height.toFixed(2),
          wi: sr.width.toFixed(2),
          ct: sr.contrast.toFixed(2),
          gl: sr.glow.toFixed(2),
          wd: sr.wind.toFixed(2),
          de: String(sr.detail),
          gr: sr.grain > 0.5 ? '1' : '0',
          th: ui.themeLight ? '1' : '0',
        });
        const url = window.location.origin + window.location.pathname + '#' + params.toString();
        try {
          await navigator.clipboard.writeText(url);
          setToast('Link copied');
        } catch {
          setToast('Copy failed');
        }
      };

      // UI -> state mapping functions
      const updateColor = (key, value) => {
        setUi((u) => ({ ...u, [key]: value }));
        const map = { cBase: 'base', cMid: 'mid', cHot: 'hot', cBg: 'bg' };
        stateRef.current[map[key]] = hexToRgb(value);
      };
      const updateNum = (key, value) => {
        setUi((u) => ({ ...u, [key]: value }));
        stateRef.current[key] = typeof value === 'boolean' ? (value ? 1.0 : 0.0) : value;
        if (key === 'grain') stateRef.current.grain = value ? 1.0 : 0.0;
        if (key === 'pixel') {
          stateRef.current.pixel = value;
          const c = canvasRef.current;
          if (c) {
            const gl = glRef.current;
            const rect = containerRef.current.getBoundingClientRect();
            const targetDpr = clamp((window.devicePixelRatio || 1) * value, 0.5, 2.0);
            dprRef.current = targetDpr;
            const w = Math.max(1, Math.floor(rect.width * targetDpr));
            const h = Math.max(1, Math.floor(rect.height * targetDpr));
            if (c.width !== w || c.height !== h) {
              c.width = w;
              c.height = h;
              gl.viewport(0, 0, w, h);
            }
          }
        }
      };

      // Presets
      const applyPreset = (p) => {
        setUi((u) => ({ ...u, ...p }));
        Object.assign(stateRef.current, {
          base: hexToRgb(p.cBase),
          mid: hexToRgb(p.cMid),
          hot: hexToRgb(p.cHot),
          bg: hexToRgb(p.cBg),
          speed: p.speed,
          turb: p.turb,
          height: p.height,
          width: p.width,
          contrast: p.contrast,
          glow: p.glow,
          wind: p.wind,
          detail: p.detail,
        });
        targetWindRef.current = p.wind;
        stateRef.current.seed = Math.random() * 1000;
      };

      // Render UI
      return (
        <div ref={containerRef} className={(ui.themeLight ? 'bg-white text-black' : 'bg-black text-white') + ' w-full h-full relative'}>
          <canvas ref={canvasRef} className="absolute inset-0 w-full h-full block" />
          {/* Panel de control de React */}
          {ui.panelOpen && (
            <div className={
              'absolute right-3 top-3 z-10 w-[min(92vw,380px)] max-h-[calc(100%-24px)] rounded-2xl border shadow-xl backdrop-blur overflow-auto ' +
              (ui.themeLight ? 'bg-white/80 border-black/10 text-neutral-900' : 'bg-slate-900/80 border-white/10 text-slate-100')
            }>
              <div className="flex items-center justify-between px-3 py-2 border-b border-white/10">
                <h1 className="text-sm font-semibold tracking-wide">Eternal Flame</h1>
                <span className="text-[11px] font-bold px-2 py-0.5 rounded-full" style={{ background: '#fdcc0d', color: '#111' }}>
                  Live
                </span>
              </div>
              <div className="p-3 space-y-2">
                {/* Presets */}
                <div className="grid grid-cols-4 gap-2">
                  <button className="text-xs rounded-full px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20" onClick={() => applyPreset(PRESETS.classic)}>Classic</button>
                  <button className="text-xs rounded-full px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20" onClick={() => applyPreset(PRESETS.blue)}>Blue</button>
                  <button className="text-xs rounded-full px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20" onClick={() => applyPreset(PRESETS.neon)}>Neon</button>
                  <button className="text-xs rounded-full px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20" onClick={() => applyPreset(PRESETS.brand)}>Spatialgineers</button>
                </div>
                {/* Colores */}
                <div className="grid grid-cols-[1fr_repeat(4,auto)] items-center gap-2">
                  <label className="text-xs opacity-80">Colores</label>
                  <input type="color" value={ui.cBase} onChange={(e) => updateColor('cBase', e.target.value)} />
                  <input type="color" value={ui.cMid} onChange={(e) => updateColor('cMid', e.target.value)} />
                  <input type="color" value={ui.cHot} onChange={(e) => updateColor('cHot', e.target.value)} />
                  <input type="color" value={ui.cBg} onChange={(e) => updateColor('cBg', e.target.value)} />
                </div>
                {/* Deslizadores */}
                {[
                  ['Velocidad', 'speed', 0, 2, 0.01],
                  ['Turbulencia', 'turb', 0, 2, 0.01],
                  ['Altura', 'height', 0.2, 2.0, 0.01],
                  ['Anchura', 'width', 0.6, 3.0, 0.01],
                  ['Contraste', 'contrast', 0.4, 3.0, 0.01],
                  ['Resplandor', 'glow', 0, 3, 0.01],
                  ['Viento', 'wind', -2, 2, 0.01],
                  ['Detalle', 'detail', 1, 7, 1],
                  ['Performance', 'pixel', 0.5, 2.0, 0.05],
                ].map(([label, key, min, max, step]) => (
                  <div key={key} className="grid grid-cols-[1fr_auto] items-center gap-3">
                    <label className="text-xs opacity-80">{label}</label>
                    <input
                      type="range"
                      min={min}
                      max={max}
                      step={step}
                      value={ui[key]}
                      onChange={(e) => updateNum(key, key === 'detail' ? parseInt(e.target.value, 10) : parseFloat(e.target.value))}
                      className="w-44"
                    />
                  </div>
                ))}
                {/* Interruptores */}
                <div className="grid grid-cols-[1fr_auto] items-center gap-3">
                  <label className="text-xs opacity-80">Auto drift</label>
                  <input type="checkbox" checked={ui.drift} onChange={(e) => { setUi((u) => ({ ...u, drift: e.target.checked })); stateRef.current.drift = e.target.checked; }} />
                </div>
                <div className="grid grid-cols-[1fr_auto] items-center gap-3">
                  <label className="text-xs opacity-80">Film grain</label>
                  <input type="checkbox" checked={ui.grain} onChange={(e) => updateNum('grain', e.target.checked)} />
                </div>
                <div className="grid grid-cols-[1fr_auto] items-center gap-3">
                  <label className="text-xs opacity-80">Mic reactivo</label>
                  <input
                    type="checkbox"
                    checked={ui.micReactive}
                    onChange={async (e) => {
                      if (e.target.checked) await initMic();
                      else {
                        micRef.current.on = false;
                        setUi((u) => ({ ...u, micReactive: false }));
                      }
                    }}
                  />
                </div>
                <div className="grid grid-cols-[1fr_auto] items-center gap-3">
                  <label className="text-xs opacity-80">Sensibilidad Mic</label>
                  <input
                    type="range"
                    min={0}
                    max={2}
                    step={0.01}
                    value={ui.micSensitivity}
                    onChange={(e) => {
                      const v = parseFloat(e.target.value);
                      setUi((u) => ({ ...u, micSensitivity: v }));
                      micRef.current.sensitivity = v;
                    }}
                    className="w-44"
                  />
                </div>
                <div className="grid grid-cols-[1fr_auto] items-center gap-3">
                  <label className="text-xs opacity-80">Viento táctil</label>
                  <input type="checkbox" checked={ui.touchWind} onChange={(e) => { setUi((u) => ({ ...u, touchWind: e.target.checked })); stateRef.current.touchWind = e.target.checked; setToast(e.target.checked ? 'Touch wind on' : 'Touch wind off'); }} />
                </div>
                <div className="grid grid-cols-[1fr_auto] items-center gap-3">
                  <label className="text-xs opacity-80">Tema claro</label>
                  <input type="checkbox" checked={ui.themeLight} onChange={(e) => setUi((u) => ({ ...u, themeLight: e.target.checked }))} />
                </div>
                <div className="grid grid-cols-2 gap-2">
                  <button className="text-xs rounded-lg px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20" onClick={() => { stateRef.current.seed = Math.random() * 1000; setToast('Randomized'); }}>Randomizar</button>
                  <button className="text-xs rounded-lg px-3 py-2 border border-white/10 bg-white/10 hover:bg-white/20" onClick={shareLink}>Compartir</button>
                </div>
                <div className="flex items-center justify-between text-[11px] opacity-80 pt-1">
                  <span>FPS: {ui.fps}</span>
                  <button className="text-xs px-2 py-1 rounded-md border border-white/10" onClick={() => setUi((u) => ({ ...u, panelOpen: !u.panelOpen }))}>{ui.panelOpen ? 'Ocultar panel' : 'Mostrar panel'}</button>
                </div>
              </div>
            </div>
          )}
          {/* Toast */}
          {toast && (
            <div className="absolute left-1/2 -translate-x-1/2 bottom-4 px-3 py-2 rounded-xl border border-white/10 bg-black/70 text-white text-xs shadow-lg">
              {toast}
            </div>
          )}
        </div>
      );
    }

    // Exponer el componente a nivel global para que otros scripts puedan montarlo
    window.EternalFlameCanvas = EternalFlameCanvas;
  </script>

  <script>
    /*
     * Código JavaScript plano para los modos 2D: "spheres", "abstract" y "custom".
     * Permite partículas en 2D que se elevan con gradientes radiales (esferas),
     * formas abstractas en órbita y partículas personalizadas basadas en imágenes PNG.
     * Incluye controles para colores, velocidad, altura, cantidad, tamaño y resplandor.
     * Soporta micrófono (amplifica las partículas) y viento táctil.
     */
    (function() {
      const canvas = document.getElementById('canvas2d');
      const ctx = canvas.getContext('2d');
      let width = 0, height = 0;
      function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
      }
      window.addEventListener('resize', resize);
      resize();

      // Configuración inicial del modo 2D con controles avanzados
      const settings = {
        mode: 'spheres',
        color1: '#fdcc0d',
        color2: '#32527b',
        speed: 1,
        height: 1,
        width: 1,
        turb: 0,
        count: 200,
        size: 1,
        glow: 1,
        windConst: 0,
        image: null,
        micSensitivity: 1,
        pointerWind: false,
        grain: false,
        drift: false,
        themeLight: false
      };

      let particles = [];
      let abstracts = [];
      let customParticles = [];
      let wind = 0;
      let targetWind = 0;

      // Micrófono
      let micEnabled = false;
      let audioCtx;
      let analyser;
      let dataArray;
      function initMic() {
        if (micEnabled) return;
        navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioCtx.createAnalyser();
          const source = audioCtx.createMediaStreamSource(stream);
          source.connect(analyser);
          analyser.fftSize = 256;
          const bufferLength = analyser.frequencyBinCount;
          dataArray = new Uint8Array(bufferLength);
          micEnabled = true;
        }).catch((err) => {
          console.error('Error al acceder al micrófono:', err);
        });
      }
      function getMicLevel() {
        if (!micEnabled || !analyser) return 0;
        analyser.getByteFrequencyData(dataArray);
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        return sum / dataArray.length / 255;
      }

      // Partículas básicas para modo "esferas"
      class Particle {
        constructor() {
          this.reset();
        }
        reset() {
          // Distribuir horizontalmente según anchura
          this.x = Math.random() * width * settings.width;
          this.y = height;
          this.radius = 10 + Math.random() * 20;
          this.life = 0;
          this.ttl = (60 + Math.random() * 80) * settings.height;
          this.vx = (Math.random() - 0.5) * 1.5;
          this.vy = -(0.6 + Math.random() * 1.2) * settings.speed;
        }
        update(micMult) {
          // Movimiento horizontal influenciado por turbulencia y viento
          this.x += this.vx * settings.turb + wind;
          this.y += this.vy - micMult * 2;
          this.life++;
          if (this.life > this.ttl || this.y < -50) {
            this.reset();
          }
        }
      }

      // Partículas para modo personalizado (usan imagen)
      class CustomParticle {
        constructor() {
          this.reset();
        }
        reset() {
          this.x = Math.random() * width;
          this.y = height;
          this.radius = 10 + Math.random() * 20;
          this.life = 0;
          this.ttl = (60 + Math.random() * 80) * settings.height;
          this.vx = (Math.random() - 0.5) * 1.5;
          this.vy = -(0.6 + Math.random() * 1.2) * settings.speed;
        }
        update(micMult) {
          this.x += this.vx + wind * 0.5;
          this.y += this.vy - micMult * 2;
          this.life++;
          if (this.life > this.ttl || this.y < -50) {
            this.reset();
          }
        }
      }

      function initParticles() {
        particles = [];
        for (let i = 0; i < settings.count; i++) {
          particles.push(new Particle());
        }
      }
      function initAbstracts() {
        abstracts = [];
        const n = Math.max(1, Math.floor(settings.count / 4));
        for (let i = 0; i < n; i++) {
          abstracts.push({
            angle: Math.random() * Math.PI * 2,
            radius: Math.random() * Math.min(width, height) * 0.4,
            speed: 0.001 + Math.random() * 0.003,
            size: 5 + Math.random() * 20,
            color: randomColor()
          });
        }
      }
      function initCustom() {
        customParticles = [];
        for (let i = 0; i < settings.count; i++) {
          customParticles.push(new CustomParticle());
        }
      }

      // Genera un color intermedio entre color1 y color2
      function randomColor() {
        const c1 = settings.color1.replace('#','');
        const c2 = settings.color2.replace('#','');
        const r1 = parseInt(c1.slice(0,2),16);
        const g1 = parseInt(c1.slice(2,4),16);
        const b1 = parseInt(c1.slice(4,6),16);
        const r2 = parseInt(c2.slice(0,2),16);
        const g2 = parseInt(c2.slice(2,4),16);
        const b2 = parseInt(c2.slice(4,6),16);
        const t = Math.random();
        const r = Math.round(r1 + (r2 - r1) * t).toString(16).padStart(2,'0');
        const g = Math.round(g1 + (g2 - g1) * t).toString(16).padStart(2,'0');
        const b = Math.round(b1 + (b2 - b1) * t).toString(16).padStart(2,'0');
        return '#' + r + g + b;
      }

      function drawParticles(micMult) {
        for (const p of particles) {
          p.update(micMult);
          const r = p.radius * settings.size;
          // gradiente radial para las esferas
          const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r * settings.height * settings.glow);
          grad.addColorStop(0, settings.color1);
          grad.addColorStop(1, settings.color2 + '00');
          ctx.beginPath();
          ctx.fillStyle = grad;
          ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      function drawAbstract(micMult) {
        const cx = width / 2;
        const cy = height / 2;
        for (const sh of abstracts) {
          sh.angle += sh.speed * settings.speed;
          sh.radius += Math.sin(sh.angle * 0.5) * 0.5;
          const x = cx + sh.radius * Math.cos(sh.angle);
          const y = cy + sh.radius * Math.sin(sh.angle);
          const s = sh.size * settings.size * micMult;
          ctx.beginPath();
          ctx.fillStyle = sh.color;
          ctx.arc(x, y, s, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      function drawCustom(micMult) {
        if (!settings.image) return;
        for (const p of customParticles) {
          p.update(micMult);
          const r = p.radius * settings.size;
          ctx.drawImage(settings.image, p.x - r, p.y - r, r * 2, r * 2);
        }
      }

      function animate() {
        // Ligeramente transparente para crear estela con tema dinámico
        ctx.fillStyle = settings.themeLight ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)';
        ctx.fillRect(0, 0, width, height);

        const micLevel = getMicLevel();
        const micMult = 1 + micLevel * 10 * settings.micSensitivity;

        if (settings.mode === 'spheres') {
          drawParticles(micMult);
        } else if (settings.mode === 'abstract') {
          drawAbstract(micMult);
        } else if (settings.mode === 'custom') {
          drawCustom(micMult);
        }

        // Ajustar viento objetivo según drift o puntero
        if (!settings.pointerWind) {
          if (settings.drift) {
            const t = Date.now() * 0.0004;
            targetWind = Math.sin(t) * 2;
          } else {
            targetWind = 0;
          }
        }
        // Aplicar interpolación hacia el viento objetivo
        wind += (targetWind - wind) * 0.05;
        // Aplicar viento constante configurado
        wind += settings.windConst * 0.02;

        // Añadir grano/ruido si está activado
        if (settings.grain) {
          ctx.save();
          ctx.fillStyle = settings.themeLight ? 'rgba(0,0,0,0.03)' : 'rgba(255,255,255,0.03)';
          for (let i = 0; i < 300; i++) {
            const gx = Math.random() * width;
            const gy = Math.random() * height;
            ctx.fillRect(gx, gy, 1, 1);
          }
          ctx.restore();
        }
        requestAnimationFrame(animate);
      }

      function initMode() {
        if (settings.mode === 'spheres') {
          initParticles();
        } else if (settings.mode === 'abstract') {
          initAbstracts();
        } else if (settings.mode === 'custom') {
          initCustom();
        }
      }

      function updateSettings() {
        settings.color1 = document.getElementById('color1').value;
        settings.color2 = document.getElementById('color2').value;
        settings.speed = parseFloat(document.getElementById('speed').value);
        settings.height = parseFloat(document.getElementById('height').value);
        settings.width = parseFloat(document.getElementById('width2d').value);
        settings.turb = parseFloat(document.getElementById('turb2d').value);
        settings.count = parseInt(document.getElementById('count').value, 10);
        settings.size = parseFloat(document.getElementById('size').value);
        settings.glow = parseFloat(document.getElementById('glow').value);
        settings.windConst = parseFloat(document.getElementById('windConst').value);
        settings.micSensitivity = parseFloat(document.getElementById('micSens2d').value);
        settings.grain = document.getElementById('grainToggle').checked;
        settings.drift = document.getElementById('driftToggle').checked;
        settings.themeLight = document.getElementById('lightToggle').checked;
        // Reinitialize based on new settings
        initMode();
        // Update canvas background according to theme
        document.getElementById('canvas2d').style.backgroundColor = settings.themeLight ? '#ffffff' : '#000000';
      }

      // Actualizar ajustes al mover sliders
      document.getElementById('color1').addEventListener('input', updateSettings);
      document.getElementById('color2').addEventListener('input', updateSettings);
      document.getElementById('speed').addEventListener('input', updateSettings);
      document.getElementById('height').addEventListener('input', updateSettings);
      document.getElementById('width2d').addEventListener('input', updateSettings);
      document.getElementById('turb2d').addEventListener('input', updateSettings);
      document.getElementById('count').addEventListener('input', updateSettings);
      document.getElementById('size').addEventListener('input', updateSettings);
      document.getElementById('glow').addEventListener('input', updateSettings);
      document.getElementById('windConst').addEventListener('input', updateSettings);
      document.getElementById('micSens2d').addEventListener('input', updateSettings);
      document.getElementById('grainToggle').addEventListener('change', updateSettings);
      document.getElementById('driftToggle').addEventListener('change', updateSettings);
      document.getElementById('lightToggle').addEventListener('change', updateSettings);

      // Micrófono toggle
      document.getElementById('micToggle').addEventListener('change', (e) => {
        if (e.target.checked) {
          initMic();
        } else {
          micEnabled = false;
        }
      });

      // Viento táctil toggle
      document.getElementById('windToggle').addEventListener('change', (e) => {
        // Activar o desactivar el viento controlado por el puntero
        settings.pointerWind = e.target.checked;
      });

      // Control de viento con movimiento del ratón
      canvas.addEventListener('mousemove', (e) => {
        if (settings.pointerWind) {
          const relX = e.clientX / width;
          // Mapea la posición horizontal a un rango de viento -2..2
          targetWind = (relX - 0.5) * 4;
        }
      });
      canvas.addEventListener('mouseleave', () => {
        if (settings.pointerWind) {
          targetWind = 0;
        }
      });

      // Carga de imagen personalizada
      document.getElementById('customImage').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (ev) => {
            const img = new Image();
            img.src = ev.target.result;
            img.onload = () => {
              settings.image = img;
              initCustom();
            };
          };
          reader.readAsDataURL(file);
        }
      });

      // Inicializar y arrancar animación
      initMode();
      animate();

      // Exponer función global para cambiar el modo
      window._update2dMode = function(mode) {
        settings.mode = mode;
        if (mode === 'custom') {
          document.getElementById('customImageWrapper').style.display = 'block';
          initCustom();
        } else {
          document.getElementById('customImageWrapper').style.display = 'none';
          initMode();
        }
      };
    })();

    /* Código para el modo 3D: utiliza Three.js para cargar modelos GLB/GLTF/OBJ y
     * genera múltiples clones con controles de color, escala, separación, rotación,
     * micrófono y viento. Proporciona un panel que puede minimizarse.
     */
    (function() {
      // Variables de escena 3D
      let scene = null;
      let camera = null;
      let renderer = null;
      let model3d = null;
      let clones3d = [];
      let threeInitialized = false;

      // Configuración para el modo 3D
      const settings3d = {
        color: '#ffffff',
        count: 1,
        scale: 1,
        speed: 1,
        spread: 2,
        micEnabled: false,
        micSensitivity: 1,
        wind: 0,
        drift: false,
        themeLight: false
      };
      // Micrófono para 3D
      let micCtx3d;
      let micAnalyser3d;
      let micData3d;
      let micOn3d = false;
      function initMic3d() {
        if (micOn3d) return;
        navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
          micCtx3d = new (window.AudioContext || window.webkitAudioContext)();
          micAnalyser3d = micCtx3d.createAnalyser();
          const source = micCtx3d.createMediaStreamSource(stream);
          source.connect(micAnalyser3d);
          micAnalyser3d.fftSize = 256;
          micData3d = new Uint8Array(micAnalyser3d.frequencyBinCount);
          micOn3d = true;
        }).catch((err) => {
          console.error('Error al acceder al micrófono 3D:', err);
        });
      }
      function getMicLevel3d() {
        if (!micOn3d || !micAnalyser3d) return 0;
        micAnalyser3d.getByteFrequencyData(micData3d);
        let sum = 0;
        for (let i = 0; i < micData3d.length; i++) {
          sum += micData3d[i];
        }
        return sum / micData3d.length / 255;
      }

      function init3d() {
        // Configurar escena, cámara y renderer
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 6);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('threeContainer').innerHTML = '';
        document.getElementById('threeContainer').appendChild(renderer.domElement);

        // Luces
        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);
        const directional = new THREE.DirectionalLight(0xffffff, 0.6);
        directional.position.set(5, 5, 5);
        scene.add(directional);

        // Escucha cambios de tamaño de la ventana
        window.addEventListener('resize', () => {
          if (!renderer || !camera) return;
          renderer.setSize(window.innerWidth, window.innerHeight);
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
        });

        animate3d();
      }

      function applyColor(object) {
        object.traverse((child) => {
          if (child.isMesh) {
            child.material = child.material.clone();
            if (child.material.color) {
              child.material.color.set(settings3d.color);
            }
          }
        });
      }

      function loadModel(dataUrl) {
        // Eliminar clones anteriores
        clones3d.forEach((c) => scene && scene.remove(c));
        clones3d = [];
        model3d = null;
        const loader = new THREE.GLTFLoader();
        loader.parse = loader.parse.bind(loader);
        loader.load(dataUrl, (gltf) => {
          model3d = gltf.scene;
          applyColor(model3d);
          updateClones3d();
        }, undefined, (e) => {
          console.error('Error al cargar modelo 3D:', e);
        });
      }

      function updateClones3d() {
        // Eliminar clones existentes
        clones3d.forEach((c) => scene && scene.remove(c));
        clones3d = [];
        if (!model3d || !scene) return;
        const total = Math.max(1, settings3d.count);
        for (let i = 0; i < total; i++) {
          const clone = model3d.clone();
          const angle = (i / total) * Math.PI * 2;
          const radius = settings3d.spread;
          clone.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
          clone.scale.set(settings3d.scale, settings3d.scale, settings3d.scale);
          clones3d.push(clone);
          scene.add(clone);
        }
      }

      function animate3d() {
        requestAnimationFrame(animate3d);
        if (!renderer || !scene || !camera) return;
        const micLevel = getMicLevel3d();
        const micMult = 1 + micLevel * settings3d.micSensitivity * 5;
        for (const obj of clones3d) {
          obj.rotation.y += settings3d.speed * 0.01;
          obj.rotation.x += settings3d.wind * 0.01;
          obj.scale.set(settings3d.scale * micMult, settings3d.scale * micMult, settings3d.scale * micMult);
        }
        // Auto drift para viento
        if (settings3d.drift) {
          settings3d.wind = Math.sin(Date.now() * 0.0005) * 2;
        }
        // Ajustar color de fondo
        renderer.setClearColor(settings3d.themeLight ? 0xffffff : 0x000000, 0);
        renderer.render(scene, camera);
      }

      // Eventos de UI para 3D
      document.getElementById('modelFile').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (ev) => {
            loadModel(ev.target.result);
          };
          reader.readAsDataURL(file);
        }
      });
      document.getElementById('color3d').addEventListener('input', (e) => {
        settings3d.color = e.target.value;
        if (model3d) {
          applyColor(model3d);
        }
      });
      document.getElementById('count3d').addEventListener('input', (e) => {
        settings3d.count = parseInt(e.target.value, 10) || 1;
        updateClones3d();
      });
      document.getElementById('scale3d').addEventListener('input', (e) => {
        settings3d.scale = parseFloat(e.target.value);
        updateClones3d();
      });
      document.getElementById('speed3d').addEventListener('input', (e) => {
        settings3d.speed = parseFloat(e.target.value);
      });
      document.getElementById('spread3d').addEventListener('input', (e) => {
        settings3d.spread = parseFloat(e.target.value);
        updateClones3d();
      });
      document.getElementById('mic3d').addEventListener('change', (e) => {
        if (e.target.checked) {
          initMic3d();
        } else {
          micOn3d = false;
        }
      });
      document.getElementById('micSens3d').addEventListener('input', (e) => {
        settings3d.micSensitivity = parseFloat(e.target.value);
      });
      document.getElementById('wind3d').addEventListener('input', (e) => {
        settings3d.wind = parseFloat(e.target.value);
      });
      document.getElementById('drift3d').addEventListener('change', (e) => {
        settings3d.drift = e.target.checked;
      });
      document.getElementById('light3d').addEventListener('change', (e) => {
        settings3d.themeLight = e.target.checked;
      });
      document.getElementById('hidePanel3d').addEventListener('click', () => {
        document.getElementById('controls3d').style.display = 'none';
        document.getElementById('controls3dCollapsed').style.display = 'block';
      });
      document.getElementById('showPanel3d').addEventListener('click', () => {
        document.getElementById('controls3d').style.display = 'block';
        document.getElementById('controls3dCollapsed').style.display = 'none';
      });

      // Exponer inicializador global
      window._init3d = function() {
        if (!threeInitialized) {
          init3d();
          threeInitialized = true;
        } else {
          // Forzar actualización de clones al volver a modo 3D
          updateClones3d();
        }
      };
    })();

    // Selección global de modos y montaje/desmontaje de React
    (function() {
      const modeSelect = document.getElementById('modeSelect');
      let isReactMounted = false;
      let isThreeMounted = false;
      modeSelect.addEventListener('change', function(e) {
        const mode = e.target.value;
        if (mode === 'original') {
          // Mostrar llama WebGL y ocultar otros modos
          document.getElementById('threeContainer').style.display = 'none';
          document.getElementById('controls3d').style.display = 'none';
          document.getElementById('controls3dCollapsed').style.display = 'none';
          document.getElementById('canvas2d').style.display = 'none';
          document.getElementById('controls2d').style.display = 'none';
          document.getElementById('controls2dCollapsed').style.display = 'none';
          document.getElementById('flame-wrapper').style.display = 'block';
          if (!isReactMounted) {
            ReactDOM.render(React.createElement(EternalFlameCanvas), document.getElementById('flame-wrapper'));
            isReactMounted = true;
          }
        } else if (mode === '3d') {
          // Mostrar modo 3D
          document.getElementById('flame-wrapper').style.display = 'none';
          document.getElementById('canvas2d').style.display = 'none';
          document.getElementById('controls2d').style.display = 'none';
          document.getElementById('controls2dCollapsed').style.display = 'none';
          document.getElementById('threeContainer').style.display = 'block';
          // Mostrar panel 3D (si estaba colapsado, mostrar panel principal)
          document.getElementById('controls3dCollapsed').style.display = 'none';
          document.getElementById('controls3d').style.display = 'block';
          if (!isThreeMounted) {
            // Inicializar Three.js sólo una vez
            if (typeof window._init3d === 'function') {
              window._init3d();
              isThreeMounted = true;
            }
          } else {
            // Actualizar clones si se cambia de modo
            if (typeof window._init3d === 'function') {
              window._init3d();
            }
          }
        } else {
          // Mostrar modos 2D (spheres, abstract, custom)
          document.getElementById('flame-wrapper').style.display = 'none';
          document.getElementById('threeContainer').style.display = 'none';
          document.getElementById('controls3d').style.display = 'none';
          document.getElementById('controls3dCollapsed').style.display = 'none';
          document.getElementById('canvas2d').style.display = 'block';
          // Al cambiar a 2D, mostrar panel principal
          document.getElementById('controls2d').style.display = 'block';
          document.getElementById('controls2dCollapsed').style.display = 'none';
          window._update2dMode(mode);
        }
      });
      // Inicialización al cargar
      if (modeSelect.value === 'original') {
        document.getElementById('threeContainer').style.display = 'none';
        document.getElementById('controls3d').style.display = 'none';
        document.getElementById('controls3dCollapsed').style.display = 'none';
        document.getElementById('canvas2d').style.display = 'none';
        document.getElementById('controls2d').style.display = 'none';
        document.getElementById('controls2dCollapsed').style.display = 'none';
        document.getElementById('flame-wrapper').style.display = 'block';
        ReactDOM.render(React.createElement(EternalFlameCanvas), document.getElementById('flame-wrapper'));
        isReactMounted = true;
      } else if (modeSelect.value === '3d') {
        document.getElementById('flame-wrapper').style.display = 'none';
        document.getElementById('canvas2d').style.display = 'none';
        document.getElementById('controls2d').style.display = 'none';
        document.getElementById('controls2dCollapsed').style.display = 'none';
        document.getElementById('threeContainer').style.display = 'block';
        document.getElementById('controls3d').style.display = 'block';
        document.getElementById('controls3dCollapsed').style.display = 'none';
        if (typeof window._init3d === 'function') {
          window._init3d();
          isThreeMounted = true;
        }
      } else {
        document.getElementById('flame-wrapper').style.display = 'none';
        document.getElementById('threeContainer').style.display = 'none';
        document.getElementById('controls3d').style.display = 'none';
        document.getElementById('controls3dCollapsed').style.display = 'none';
        document.getElementById('canvas2d').style.display = 'block';
        document.getElementById('controls2d').style.display = 'block';
        document.getElementById('controls2dCollapsed').style.display = 'none';
        // Inicializa el modo 2D seleccionado (incluyendo 'custom')
        window._update2dMode(modeSelect.value);
      }
    })();
  </script>
</body>
</html>